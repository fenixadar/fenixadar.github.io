<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FenixAdar Blog</title>
  
  <subtitle>liaoyuanyue blog</subtitle>
  <link href="https://fenixadar.github.io/atom.xml" rel="self"/>
  
  <link href="https://fenixadar.github.io/"/>
  <updated>2023-01-16T01:31:48.820Z</updated>
  <id>https://fenixadar.github.io/</id>
  
  <author>
    <name>FenixAdar</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在阿里云ACK部署Milvus生产集群的坑</title>
    <link href="https://fenixadar.github.io/2023/01/11/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ACK%E9%83%A8%E7%BD%B2Milvus%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E7%9A%84%E5%9D%91/"/>
    <id>https://fenixadar.github.io/2023/01/11/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ACK%E9%83%A8%E7%BD%B2Milvus%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E7%9A%84%E5%9D%91/</id>
    <published>2023-01-11T13:13:50.000Z</published>
    <updated>2023-01-16T01:31:48.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在阿里云ACK部署Milvus生产集群的坑"><a href="#在阿里云ACK部署Milvus生产集群的坑" class="headerlink" title="在阿里云ACK部署Milvus生产集群的坑"></a>在阿里云ACK部署Milvus生产集群的坑</h1><p>因工作需要，需在阿里云ACK部署Milvus生产集群，但依照官方文档 <a href="https://milvus.io/docs/install_cluster-milvusoperator.md">Install Milvus Cluster with Milvus Operator</a> 安装的时候，遇到几个坑，在此记录下。</p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-1-准备资源"><a href="#1-1-准备资源" class="headerlink" title="1.1 准备资源"></a>1.1 准备资源</h3><p>可先参考 <a href="https://milvus.io/docs/prerequisite-helm.md">Environment Checklist for Milvus Milvus on Kubernetes</a> 在云上购买和配置相关的资源。</p><p>本人购买的云资源是  </p><ul><li>ACK托管版  </li><li>K8S版本 1.24.6-aliyun.1   </li><li>3台 16vCPU 32GB ecs.c6e.4xlarge  </li><li>1台 64vCPU 64GB ecs.ic5.16xlarge</li></ul><p>因为读多写少，主要是查询任务，计划是3台16核32G的ECS用于部署QueryNode外的所有负载，先部署1台64核64G用作QueryNode，后续有需求再横向扩展。</p><h3 id="1-2-配置存储类"><a href="#1-2-配置存储类" class="headerlink" title="1.2 配置存储类"></a>1.2 配置存储类</h3><p>这些配置并不在Milvus的安装文档内，但不执行的话，后续安装过程会出错。创建好ACK资源后，在阿里云控制台创建新的存储类，主要是指定type和zoneId。我的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储卷类型 云盘</span><br><span class="line">存储驱动 CSI</span><br><span class="line">参数添加 key是&quot;type&quot;，值是&quot;cloud_essd&quot;，key是&quot;zoneId&quot;，值是&quot;cn-shanghai-g&quot;</span><br><span class="line">回收策略 和 绑定模式 可用默认的</span><br></pre></td></tr></table></figure><p>type指定cloud_essd的原因是这是性能最好的云盘类型，但需要特别注意节点的主机所支持的存储是否支持pvc要求的类型，否则会导致负载启动不成功的问题，一直在容器创建状态。  </p><p>指定zoneId是因为有时候pvc自动创建的pv有可能跑到其他可用区去，进而造成pod一直在 Pending 状态，提示node affinity conflict。类似“0&#x2F;13 nodes are available: 2 node(s) were unschedulable, 3 node(s) had volume node affinity conflict, 8 node(s) didn’t match Pod’s node affinity&#x2F;selector.”这样的报错。这时候你查看pv的yaml会发现pv的zoneId和pod所在的节点不在一个可用区。  </p><p>创建完成后，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch storageclass &#123;你创建的存储类的名称，不需要花括弧&#125; -p &#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>可执行<code>kubectl get sc</code>验证。</p><p>参考文档：  </p><ul><li><a href="https://help.aliyun.com/document_detail/134767.html">云盘存储卷概述</a></li><li><a href="https://help.aliyun.com/document_detail/134859.html">使用云盘动态存储卷</a></li><li><a href="https://help.aliyun.com/document_detail/25378.htm">实例规格族</a></li></ul><h2 id="二、安装-Milvus"><a href="#二、安装-Milvus" class="headerlink" title="二、安装 Milvus"></a>二、安装 Milvus</h2><p>安装过程基本上按照教程即可，但我希望Milvus单独使用节点池里面的所有节点，不希望和其他负载共享，所以会配置节点亲和性。我的亲和性配置是：3台16vCPU 32GB ECS的节点池，设置节点标签，键:”milvus”，值:”components”，1台64vCPU 64GB ECS的节点池，设置节点标签 键:”milvus”，值:”querynode”。</p><h3 id="2-1-安装-cert-manager"><a href="#2-1-安装-cert-manager" class="headerlink" title="2.1 安装 cert-manager"></a>2.1 安装 cert-manager</h3><p>参考 <a href="https://milvus.io/docs/install_cluster-milvusoperator.md#1-Install-cert-manager">Install cert-manager</a></p><p>遇到不能访问github.com，也可先在别的机器下载再复制过来。 安装后，会出现新的命名空间”cert-manager”。确认安装成功后，在阿里云控制台更改cert-manager命名空间下负载的节点亲和性，设置为必须满足，标签名是””milvus:，操作符: “In”，标签值:”components”。</p><h3 id="2-2-安装-Milvus-Operator"><a href="#2-2-安装-Milvus-Operator" class="headerlink" title="2.2 安装 Milvus Operator"></a>2.2 安装 Milvus Operator</h3><p>参考 <a href="https://milvus.io/docs/install_cluster-milvusoperator.md#2-Install-Milvus-Operator">Install Milvus Operator</a></p><p>安装后，会出现新的命名空间”milvus-operator”。确认安装成功后，在阿里云控制台更改milvus-operator命名空间下负载的节点亲和性，同样设置为必须满足，标签名是””milvus:，操作符: “In”，标签值:”components”。</p><h3 id="2-3-安装-Milvus-cluster"><a href="#2-3-安装-Milvus-cluster" class="headerlink" title="2.3 安装 Milvus cluster"></a>2.3 安装 Milvus cluster</h3><p>参考 <a href="https://milvus.io/docs/install_cluster-milvusoperator.md#Install-a-Milvus-cluster">Install a Milvus cluster！</a></p><p>创建新的命名空间 milvus，并切换到新的命名空间<code>kubectl config set-context $(kubectl config current-context) --namespace=milvus</code>。下载官方的”milvus_cluster_default.yaml”并修改，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: milvus.io/v1beta1</span><br><span class="line">kind: Milvus</span><br><span class="line">metadata:</span><br><span class="line">  name: my-release</span><br><span class="line">  labels:</span><br><span class="line">    app: milvus</span><br><span class="line">spec:</span><br><span class="line">  mode: cluster</span><br><span class="line">  dependencies: &#123;&#125;</span><br><span class="line">  components:</span><br><span class="line">    affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: milvus</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - components</span><br><span class="line">    dataCoord:</span><br><span class="line">      replicas: 1</span><br><span class="line">    dataNode:</span><br><span class="line">      replicas: 1</span><br><span class="line">    indexNode:</span><br><span class="line">      replicas: 1</span><br><span class="line">    proxy:</span><br><span class="line">      replicas: 1</span><br><span class="line">    indexCoord:</span><br><span class="line">      replicas: 1</span><br><span class="line">    queryNode:</span><br><span class="line">      replicas: 1</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpu: &#x27;60&#x27;</span><br><span class="line">        requests:</span><br><span class="line">          cpu: &#x27;60&#x27;</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: milvus</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - querynode</span><br><span class="line">    rootCoord:</span><br><span class="line">      replicas: 1</span><br><span class="line">  config: &#123;&#125;</span><br></pre></td></tr></table></figure><p>配置的重点在于明确各个负载的副本数，并特别设置了queryNode的节点亲和性，资源占用与限制，因为承载queryNode的节点是64核，所以cpu设置为60，如果你的机器不是64核，此处需修改。yaml也明确了query node的副本数，横向扩展时，可以修改此处，并重新<code>kubectl apply</code>。  </p><p>而后执行安装<code>kubectl apply -f ./milvus_cluster_default_modify.yaml</code>，稍等一会儿<code>kubectl get pods</code>，会发现etcd无法启动成功，这是因为官方设置etcd的PVC总量是10G，而阿里云essd，需要至少20G才能初始化。修改etcd的yaml文件，将storage由原来的10Gi改为20Gi，部分yaml代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 20Gi</span><br><span class="line">  storageClassName: alicloud-disk-essd-shanghai-g</span><br><span class="line">  volumeMode: Filesystem</span><br></pre></td></tr></table></figure><p>依次 kubectl apply 修改三个etcd的pvc总量，而后pv可成功初始化，etcd亦可成功运行。所有pod成功启动后，更改milvus 命名空间下所有有状态负载的节点亲和性。到这里，milvus本身就安装好了。  </p><p>这里注意下，milvus自身的组件是带”my-release-milvus-“前缀的，且都在无状态负载下，不要手动修改这些组件的包括亲和性、资源限制在内的任何配置，因为修改了也没用，如果刚没修改，可在”milvus_cluster_default_modify.yaml”修改，并重新<code>kubectl apply -f ./milvus_cluster_default_modify.yaml</code></p><h3 id="2-4-创建-Milvus-连接端口"><a href="#2-4-创建-Milvus-连接端口" class="headerlink" title="2.4 创建 Milvus 连接端口"></a>2.4 创建 Milvus 连接端口</h3><p>在阿里云ACK控制台-&gt;网络-&gt;服务中创建服务，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型 负载均衡 私网访问 标准型I（slb.s2.small）</span><br><span class="line">关联 my-release-milvus-proxy</span><br><span class="line">外部流量策略 Local</span><br><span class="line">端口映射 19530 和 9091</span><br></pre></td></tr></table></figure><p>外部流量策略，需要关注下网络插件类型，如果是 Terway ，选择 Local 亲测没问题。如果是 Flannel ，出现连接不上的情况，可选择 Cluster 试试看。</p><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><p>可在 <a href="https://milvus.io/docs/example_code.md">官方 Hello Milvus 代码</a> ，下载并测试milvus是否可以正常连接并使用。</p><p>注意下，Milvus的身份验证功能需要手动配置开启，默认是无用户名密码也可连接，即使你设置了用户名和密码。参考 <a href="https://milvus.io/docs/authenticate.md">身份验证</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在阿里云ACK部署Milvus生产集群的坑&quot;&gt;&lt;a href=&quot;#在阿里云ACK部署Milvus生产集群的坑&quot; class=&quot;headerlink&quot; title=&quot;在阿里云ACK部署Milvus生产集群的坑&quot;&gt;&lt;/a&gt;在阿里云ACK部署Milvus生产集群的坑&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>传统企业数字化架构设计</title>
    <link href="https://fenixadar.github.io/2022/10/01/%E4%BC%A0%E7%BB%9F%E4%BC%81%E4%B8%9A%E6%95%B0%E5%AD%97%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://fenixadar.github.io/2022/10/01/%E4%BC%A0%E7%BB%9F%E4%BC%81%E4%B8%9A%E6%95%B0%E5%AD%97%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-10-01T03:07:43.000Z</published>
    <updated>2023-01-16T01:31:48.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统企业数字化架构设计"><a href="#传统企业数字化架构设计" class="headerlink" title="传统企业数字化架构设计"></a>传统企业数字化架构设计</h1><h2 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h2><p>传统企业数字化架构设计可分为2层，4种架构，分别是业务架构，数据架构，应用架构，技术架构。业务架构是上层，他驱动应用、数据、技术架构，反过来，应用、数据、技术架构是下层，他支撑业务架构的实现。除此之外，我们还应该在业务架构之上，再设立战略层，战略层主要由公司高管设计。</p><ol><li>业务架构<br>业务架构需要知道为什么要做，做什么，怎么做，谁来做四件事。</li></ol><ul><li>为什么做是一切的缘起，需要理解公司战略目标</li><li>做什么，即公司想实现或能提供的业务服务</li><li>怎么做是基于做什么的基础上，细化提供业务服务所需要的业务流程</li><li>谁来做，指的是业务服务的执行方。</li></ul><ol start="2"><li>应用架构<br>应用架构需要解决应用有哪些，以及对应的功能点。</li><li>数据架构<br>数据架构需要解决数据的类型、来源，后续还需要针对不同的场景和功能，设计确定数据模型，存储方式，数据处理加工方式。</li><li>技术架构<br>技术架构需要解决技术需求、选型、发展路径等的问题。诸如，技术栈，技术平台，技术框架，中间件，部署方式等等。</li></ol><p>从阶段上看，一般架构设计到实施，可以分为启动阶段，架构设计阶段，研发实施阶段，上线运维阶段。每个阶段要解决的问题重点各不相同。</p><ul><li>启动阶段，需要做好战略调研，确定方向。为下一阶段做好准备。</li><li>架构设计阶段，首先根据公司业务模式，商业模式，规划业务架构，分析需求，详细设计功能，流程，数据等。第二步，根据业务架构，设计规划应用，数据，技术架构，还应当评估风险，做可行性分析等。</li><li>研发实施阶段，根据总体需求规模，研发实施阶段时间长度可能是1年，也可能是5年，所以该阶段需详细拆解任务项，制定时间表。很重要的是，如果涉及公司组织架构调整，商业合作伙伴变更等，也需要制定相对应时间表。另外，很多公司做数字化转型前，经常会存在历史系统，这些系统可能是之前采购的SaaS系统，或是外包研发的系统等，需要对遗留系统进行改造，或是迁移等动作，也均需考虑在内。</li><li>上线运维阶段，该阶段未必是研发实施后，可能会和研发实施有交叉，研发实施部分功能，上线运维，再研发实施，而后再上线运维。这阶段在维护的基础上，需要收集遗漏或者缺失的功能，以便在后续的优化完善。</li></ul><p>可以看出，数字化转型的架构设计，不仅仅是IT部门，或是CTO,CIO的事，而是需要公司达成一致，至少是需要公司高层达成一致。前期的战略设定，后续的人员招聘，组织架构调整，上线培训使用等，都需要各个部门紧密配合。</p><h2 id="二、-业务架构设计"><a href="#二、-业务架构设计" class="headerlink" title="二、 业务架构设计"></a>二、 业务架构设计</h2><p>业务架构必须基于企业的战略来做，脱离了企业战略，业务架构就无法真正意义上实现其价值，也就成了无源之水，无本之木。基于战略，我们可以知道为什么要做，而后，业务架构还需要解决做什么，怎么做，谁来做的问题。做什么指的是所提供的业务功能，怎么做是业务流程，谁来做是组织架构，此外我们还可以引入商业模式。另外，业务架构的设计，往往牵扯到公司多个部门甚至事业部，而大多数企业在做数字化转型前，或多或少都会有已有系统，无论是采购亦或者外包开发，所以业务架构设计往往是跨部门，跨系统的，这也要求我们在做业务架构设计时需要将这些因素考虑在内。</p><h3 id="2-1-企业战略"><a href="#2-1-企业战略" class="headerlink" title="2.1 企业战略"></a>2.1 企业战略</h3><p>企业战略往往由公司董事或高层制定，而我们所需要做的，就是对标企业战略目标，理解公司战略驱动因素。我们可以通过与高层进行访谈，了解战略的由来，逻辑。可以通过收集内外部信息，包括政策，友商策略等，再结合案例与最佳实践，最终达到理解战略意图。<br>理解战略意图后，我们需要分解战略大目标，而后就每个目标进一步分解为达成目标所需要的策略动作，策略动作可以从之前提到的做什么，怎么做，谁来做，商业模式几方面考虑，最后总结即可得到业务架构图。<br>以数字化转型这个战略目标为例，一般而言，传统企业做数字化转型的三个目标是降本，增效，增收。达成降本目标所设定的服务是，提供某个智能化平台，通过AI算法，达到减少积压库存的目标。达成增效目标是建立采购平台，大客户可通过平台自行下单采购，提高下单效率。达成增收目标所设定的是建立客服主动回访机制，通过主动回访，提高客户复购率。最后，我们需要提取各项因素，分析细化，总结为业务功能，流程，组织架构。</p><h3 id="2-2-业务功能"><a href="#2-2-业务功能" class="headerlink" title="2.2 业务功能"></a>2.2 业务功能</h3><p>分析业务功能，可以从价值链开始，逐步拆解到功能域，二级功能域等。是一个从大到小逐步细化的过程。我们需要分析拆解公司内所能提供的对内和对外的服务项。<br>以医药制造企业为例，价值链最顶级是人力行政，研发，采购，生产，物流，销售，售后等。而后需要对每项进行再一次拆解，诸如销售可拆解为大客户渠道，药店渠道，电商渠道等，作为二级功能域。</p><h3 id="2-3-业务流程"><a href="#2-3-业务流程" class="headerlink" title="2.3 业务流程"></a>2.3 业务流程</h3><p>业务流程也可逐层拆解，诸如线上购买商品，“搜索-&gt;进入商品详情页-&gt;下单支付”，这是一级主干流程，主干流程内的各个节点可以继续拆解，诸如搜索可能会有筛选项，详情页需要选择型号、规格、尺码，下单支付则可能会出现不同的支付渠道。再往下还需要设定规则，诸如某些场景不允许使用信号卡，或是不允许使用货到付款等。</p><h3 id="2-4-组织架构"><a href="#2-4-组织架构" class="headerlink" title="2.4 组织架构"></a>2.4 组织架构</h3><p>组织结构需要考虑是否改动或者新增新的组织体系，诸如原有物流部新增电商物流岗位，新增电商客服部等。<br>其次，组织架构不仅是公司内的调整，可能还会涉外部合作伙伴的变更，合作渠道的变更，都需要考虑在内。诸如新增电商渠道，需要考虑与之相关的渠道链路，考虑组织架构的调整。</p><ul><li>最上层是个人客户，企业客户。</li><li>第二层是售卖渠道，有第三方电商平台，自有官网商城等。</li><li>第三层有客服，物流，售后，运营，品牌，品项等。</li><li>第四层有财务，人力，行政等基础支持性部门。</li></ul><h3 id="2-5-案例"><a href="#2-5-案例" class="headerlink" title="2.5 案例"></a>2.5 案例</h3><p>本节以在官方商城购买商品作为虚拟案例。我们从业务功能，业务流程，分支流程进行说明，这几部分是自上而下，逐步拆解的过程。</p><ol><li>业务功能<br>也即在官方商城购买商品这个服务场景。</li><li>业务流程<br>主干流程：客户进入商城某个商品详情页，在登录后进行购买并支付。<br>分支流程：</li></ol><ul><li>查找商品流程</li><li>选择具体SKU流程</li><li>登录流程</li><li>选择收货地址流程</li><li>支付流程<br>详细阐述对每个分支流程再次细化，直至全覆盖每个流程的每个分支以及其处理规则。</li></ul><ol start="3"><li>组织架构<br>如涉及组织架构变更，还需明确所产生的调整策略，涵盖时间，范围，方式等。</li></ol><h2 id="三、应用架构设计"><a href="#三、应用架构设计" class="headerlink" title="三、应用架构设计"></a>三、应用架构设计</h2><p>应用架构包含一系列应用以及之间交互方式，应用架构关注的应用的功能以及之间的交互方式，而不是具体到每个应用内部的实现技术。</p><h3 id="3-1-设计步骤"><a href="#3-1-设计步骤" class="headerlink" title="3.1 设计步骤"></a>3.1 设计步骤</h3><ol><li>梳理应用架构前，需梳理好业务架构，也即整理好业务功能，细化流程，明确流程内处理规则。比如登录场景，需考虑登录成功与失败的场景，并考虑忘记密码的场景。</li><li>识别每个流程，每个分支，处理规则背后的需求点。比如忘记密码，则会产生重置密码的流程，进而会有发送重置密码链接到注册邮箱的需求。</li><li>对需求点进行分类，将其归类到各个系统功能，注意这里开始出现偏技术向的内容，诸如，支付管理，用户管理等，此外类似日志管理这类后台功能也是系统的一部分。如果出现各部门业务功能似乎就可以直接划分成系统，这时候可以考虑是否有更优方式组织系统划分方式，优化使用感受。</li><li>按照终端-&gt;系统以及内部功能-&gt;底层后台服务的层次排列，形成功能架构图。注意不应出现过于技术向的构件，诸如不应出现MySQL，ELK这类词汇，而是面向功能进行分层排列。对于过大的构件，也应拆解成小构件，这其实是构件细粒度的问题。</li><li>根据之前的需求分类，定义各系统各功能点开发顺序，定义迭代内容。注意，现实情况一般是并非所有功能和需求都是新增的，也可能是对原有系统的重构，完善优化，重写等，也可能是原有系统就已满足的。</li><li>定义接口，如果可能的话，可细化输出时序图，数据库表结构等。</li></ol><h2 id="四、-数据架构设计"><a href="#四、-数据架构设计" class="headerlink" title="四、 数据架构设计"></a>四、 数据架构设计</h2><p>数据架构描述的是企业的主要数据类型和来源，物理和逻辑数据资产，数据管理。</p><h3 id="4-1-设计内容"><a href="#4-1-设计内容" class="headerlink" title="4.1 设计内容"></a>4.1 设计内容</h3><p>数据架构设计的内容可以归纳为以下5个方面：</p><ul><li>数据架构类型及其来源，诸如订单库，商品库，操作日志等</li><li>数据模型，诸如订单模型，BI星型模型等</li><li>数据存储，诸如，关系型数据库，图数据库</li><li>数据流，诸如数据治理过程等</li><li>数据管理，诸如安全规范等。</li></ul><p>从落地角度来看，数据架构设计可分为三大块</p><ol><li>现有或未来需要的数据，这既是需求，也是现状<br>  a. 针对不同的部门，不同的业务，分析已有的数据，并通过调研分析未来所需要的数据。<br>  b. 设计跨部门的数据结构，总结主数据结构<br>  c. 分析非结构或半结构化的数据的应用场景</li><li>设计物理和逻辑数据资产，数据生命周期，数据流<br>  a. 设计逻辑数据资产模型，可使用ER图表示<br>  b. 设计物理数据资产结构，可能是OLAP，JSON，XML等<br>  c. 数据生命周期设计，诸如分库分表场景，热数据定时迁移到历史表中。<br>  d. 数据流设计。第一应关注用户本身是如何使用数据的，数据应该是从哪个系统往哪个系统流转，直到最后被使用。第二明确数据处理过程，可设计ETL过程，用来将原始数据处理成可展示的目标数据。</li><li>设计数据管理规范<br>数据管理规范包含三点，一是数据标准，二是数据质量，三是数据安全</li></ol><h3 id="4-2-设计步骤"><a href="#4-2-设计步骤" class="headerlink" title="4.2 设计步骤"></a>4.2 设计步骤</h3><ol><li>分析现状，识别未来需求<br>注意分析和识别需是横跨不同的部门，不同的业务。关注可提取作为主数据的数据类型和来源。<br>在识别数据类型时，可借鉴UC矩阵的方式，仔细梳理每个业务产生和消费的数据。</li><li>数据建模<br>数据建模必须建立在业务的基础上，具体来说，可将业务进行分层，而后进行分析。</li></ol><ul><li>通过业务域发现数据域</li><li>通过业务流程，发现数据实体，属性，关系</li><li>通过功能和处理规则，逐步细化数据实体，属性，关系<br>数据建模是数据架构设计的核心，是最重要的一步。</li></ul><ol start="3"><li>定义数据生命周期<br>由于数据量大等原因，可能对系统产生性能产生影响，有时候需要制定数据生命周期，定期清理或迁移数据。也有可能是某些场景，诸如电商抢购，用户下单后30分钟未付款应关闭订单等等。</li><li>规划数据存储与分布<br>这步决定了数据应该如何存储以及分布，举个例子，数据是结构化还是非结构化的，就要考虑数据存储在某种关系型数据库上，或是非结构化的数据库上。</li><li>设计数据流<br>针对BI报表甚至是AI的需求，我们往往会需要做数据治理，处理原始数据，最终可能是落地到数仓，或是报表，仪表盘等。</li><li>制定数据管理规范<br>这点主要是根据企业或实际业务要求，定义数据标准，质量，安全。</li></ol><h2 id="五、-技术架构设计"><a href="#五、-技术架构设计" class="headerlink" title="五、 技术架构设计"></a>五、 技术架构设计</h2><h3 id="5-1-设计内容"><a href="#5-1-设计内容" class="headerlink" title="5.1 设计内容"></a>5.1 设计内容</h3><p>技术架构设计是很多技术人最擅长接触最多的部分，大概涉及以下几方面</p><ul><li>技术需求，主要分析业务架构，应用架构，数据架构，所设定的需求作为起点</li><li>技术选型，针对平台，组件，框架等进行选型</li><li>物理选型，考虑是否使用公有云，或者私有化部署</li><li>选型管理，针对所需要的技术进行指标评估，制定选型标准</li></ul><h3 id="5-2-设计步骤"><a href="#5-2-设计步骤" class="headerlink" title="5.2 设计步骤"></a>5.2 设计步骤</h3><ol><li><p>分析技术需求，主要包含识别需求所需要的技术以及部署位置。<br>技术架构设计的第一步，是分析技术需求，技术需求必须以业务架构，应用架构，数据架构为源。如，是否有高并发和弹性伸缩的需求？甲方或公司是否对数据存储安全有要求？现有团队技术栈情况等。</p></li><li><p>技术选型，盘点现有系统使用的技术，并与需求进行对比，明确差异和差距，最后选择合适的技术<br>可以结合横向和纵向进行分析，举个例子，数据库选型，横向可以分析 SQLServer、MySQL、TiDB之间的差异。纵向可以分析各数据库的功能，质量，现状，社区，文档，法律风险，未来发展趋势等。</p></li><li><p>影响分析，对比技术架构目标和现状，明确成本，规模，学习曲线等影响。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统企业数字化架构设计&quot;&gt;&lt;a href=&quot;#传统企业数字化架构设计&quot; class=&quot;headerlink&quot; title=&quot;传统企业数字化架构设计&quot;&gt;&lt;/a&gt;传统企业数字化架构设计&lt;/h1&gt;&lt;h2 id=&quot;一、总览&quot;&gt;&lt;a href=&quot;#一、总览&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>个人虚拟化存算分离改造</title>
    <link href="https://fenixadar.github.io/2022/09/10/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%98%E7%AE%97%E5%88%86%E7%A6%BB%E6%94%B9%E9%80%A0/"/>
    <id>https://fenixadar.github.io/2022/09/10/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%98%E7%AE%97%E5%88%86%E7%A6%BB%E6%94%B9%E9%80%A0/</id>
    <published>2022-09-10T03:06:41.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建并开始使用自己的虚拟化集群也差不多3-4年了，期间遇到不少的坑，也收获颇丰。但从始至终一直有一个担忧，就是数据安全存储问题，因为不管是HDD还是NVMe SSD，都是直接插在主板上，没有做任何备份或者RAID方案，这也意味着一旦硬盘损毁，资料也将面临损毁的风险。  化解风险的方法也挺多，曾想过诸如组vSan集群，主机上插硬RAID卡等，但各有优缺点，最后决定在整体架构上让计算和存储分离。</p><p>可查看 <a href="https://fenixadar.github.io/2021/06/04/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/">个人虚拟化集群搭建教程</a></p><h1 id="一、为什么要存算分离？"><a href="#一、为什么要存算分离？" class="headerlink" title="一、为什么要存算分离？"></a>一、为什么要存算分离？</h1><p>网上关于存算分离的探讨非常多，更多的是从企业的角度里分析。对于我个人做虚拟化集群而言，大致也是相似的，主要有如下几点：</p><ol><li>万兆网络事实上提供了存算分离的基础，且基于iSCSI的成本并不高。很多企业会用FC，但对于个人而言，iSCSI完全足够，而且使用iSCSI可以使用现成的网络，无需做太多改造动作。</li><li>解决因存算耦合造成资源浪费的问题。存算耦合场景经常会遇到性能不足或者空间不足的问题，最典型的就是当你使用NVMe SSD承载io速度要求高的系统时，很容易会遭遇SSD空间不足的问题。而单台机器毕竟性能有限，承载服务不可能太多。</li><li>用VM DRS在不同主机间迁移系统，耗费时间较长，不方便。如果是在分离的场景下，弹性拓展会变得很容易，数据甚至都不需要移动。</li></ol><h1 id="二、改造步骤"><a href="#二、改造步骤" class="headerlink" title="二、改造步骤"></a>二、改造步骤</h1><h2 id="2-1-购买设备"><a href="#2-1-购买设备" class="headerlink" title="2.1 购买设备"></a>2.1 购买设备</h2><p>共需购买三类设备，网络设备、NAS、硬盘等。</p><ol><li>网络设备</li></ol><ul><li>一台万兆光口交换机</li><li>光纤线或电缆若干条</li><li>光口转电口模块（可能需要）</li></ul><ol start="2"><li><p>NAS、升级配件、硬盘<br>关于NAS与硬盘的选择，可以参考《威联通NAS实测》博文，里面已经有比较清楚的描述了。总之，如是家用且没有独立放机柜或者设备的房间，建议不要购买企业级的NAS设备，可以选择购买普通家用的品牌NAS。硬盘建议从正规渠道购买，不要贪图便宜去购买价差很大的硬盘。</p></li><li><p>UPS<br>可以购买UPS设备，当意外断电时，可有效保障数据存储安全。个人买的是山特TG-BOX850。</p></li><li><p>服务器上的万兆网卡</p></li></ol><p>注意下：</p><ul><li>应提前确定网络类型，诸如10G或者25G甚至更高，比如购买的是10G，那么相对应的交换机，电缆，NAS配件，万兆网卡应确保能适配，举例，10G的口是SFP+，而25G的口是SFP28+，不同的速率可能会对应不同的光模块。同时，也应该电缆或者光转电模块和交换机品牌是否兼容等，这些需要提前确定并跟商家进行咨询。</li><li>个人安装的是10G，但10G的问题在于，网速会成为某些场景的性能瓶颈点，举个例子，10G网速上限在1200MB&#x2F;s左右，而SSD顺序读写轻松可达3500MB&#x2F;s。但依旧不选择25G网络的原因有，一是25G网络伴随着整体建设成本急剧高涨，二是25G网络设备大部分是企业级的，噪音较大，三是因为日常大部分是随机读写场景，实测NAS速率后，发现随机读写不大会被网络速率限制。</li></ul><h2 id="2-2-安装迁移步骤"><a href="#2-2-安装迁移步骤" class="headerlink" title="2.2 安装迁移步骤"></a>2.2 安装迁移步骤</h2><ol><li>安装好NAS，包括升级配件（万兆网卡、内存、NVMe SSD等），并将NAS接入光口交换机。</li><li>光口交换机接入路由器，此处可能会需要用到光口转电口模块。接入路由器后，需要为NAS配置静态ip，以避免后续因ip发生变化导致iSCSI连接失败的问题，并确保NAS可以接入互联网，后续需更新升级NAS系统。</li><li>若有购买UPS，可以将电源接在UPS上，并连接好USB数据线。</li><li>开启NAS，安装QTS系统，不建议安装hero系统，实测hero系统尤其是写入性能较差。若有接入UPS，需要在NAS UPS管理页面做配置。</li><li>创建 RAID 10 存储池，磁盘同步需大约1天左右，也可以选择不等待直接进行下一步</li><li>创建高速缓存加速，选择 读写高速缓存 RAID1，缓存模式选择全部I&#x2F;O。</li><li>开启iSCSI存储与光纤通道，新建iSCSI目标。</li><li>新建iSCSI LUN，选择厚置备，区块大小512B（不要选择4KB，否则vmware无法识别）,勾选“用SSD缓存提升性能”</li><li>在vCenter中的”主机-&gt;配置-&gt;存储适配器-&gt;vmhba64-&gt;动态发现”，添加发送目标服务器，填写iSCSI服务器地址，也即NAS的IP，若有设置CHAP，此处需要填写用户名与密钥，保存后并切换到”静态发现-&gt;身份验证”，再一次填写用户名和密钥。</li><li>重新扫描存储，而后切换到”主机-&gt;配置-&gt;存储设备”，点击刷新，会出现一个新磁盘，也即iSCSI Disk。</li><li>点击vCenter的主机，新建数据存储，类型选择VMFS，设备选择刚刚新出现的磁盘，版本选择VMFS6。</li><li>在vCenter中将虚拟机迁移至新创建的存储设备中。</li></ol><h2 id="2-3-性能调优"><a href="#2-3-性能调优" class="headerlink" title="2.3 性能调优"></a>2.3 性能调优</h2><h3 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h3><ol><li>控制台-网络与虚拟交换机-网络适配器 页面</li></ol><ul><li>找到在用的适配卡，设定，IPv4使用固定IP地址，设定成之前在路由器配置的IP。巨帧封包设定9000，巨帧大小对顺序写入性能影响较大，默认的1500，顺序写入速度直降至450MB&#x2F;s左右。</li><li>FEC，如果对应的设备不支持FEC，可以选择关闭。</li></ul><ol start="2"><li>将RAID 10 存储池的磁盘同步速度级设置为低，也即服务优先</li></ol><h3 id="vCenter"><a href="#vCenter" class="headerlink" title="vCenter"></a>vCenter</h3><ol><li>在ESXi控制台或者vCenter的存储选项卡中，配置iSCSI适配器，添加动态目标与静态目标，在高级设置处配置 FirstBurstLength、MaxBurstLength、MaxRecvDataSegLen 为 524288。</li><li>iSCSI开启巨帧与禁用延迟 ACK<br>参考<br><a href="https://kb.vmware.com/s/article/1002598?lang=zh_cn">ESX&#x2F;ESXi 主机的某些存储阵列可能存在读取或写入性能问题</a><br><a href="https://docs.vmware.com/cn/VMware-vSphere/6.0/com.vmware.vsphere.hostclient.doc/GUID-F9CE816E-7AB0-401F-AE1C-F0E91C35872F.html">为 iSCSI 启用巨帧</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;搭建并开始使用自己的虚拟化集群也差不多3-4年了，期间遇到不少的坑，也收获颇丰。但从始至终一直有一个担忧，就是数据安全存储问题，因为不管是H</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>威联通NAS TS-873A 实测</title>
    <link href="https://fenixadar.github.io/2022/08/15/%E5%A8%81%E8%81%94%E9%80%9ANAS%20TS-873A%20%E5%AE%9E%E6%B5%8B/"/>
    <id>https://fenixadar.github.io/2022/08/15/%E5%A8%81%E8%81%94%E9%80%9ANAS%20TS-873A%20%E5%AE%9E%E6%B5%8B/</id>
    <published>2022-08-15T02:43:05.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、为什么要NAS？"><a href="#一、为什么要NAS？" class="headerlink" title="一、为什么要NAS？"></a>一、为什么要NAS？</h1><p>虽然每个人都有各自的理由，但核心诉求点集中在安全存储和备份分享数据，支持远程访问，可安装包括虚拟化、web服务器等的额外拓展等。NAS的本质是网络+存储。</p><p>我使用NAS主要目的是：</p><ol><li>在存算分离环境中，通过iSCSI服务，使用NAS提供的储存服务。</li><li>安全存储并备份虚拟化系统所必需的文件。</li><li>安全存储并备份文档，照片等文件。</li></ol><h1 id="二、NAS有哪些可选项"><a href="#二、NAS有哪些可选项" class="headerlink" title="二、NAS有哪些可选项"></a>二、NAS有哪些可选项</h1><p>目前家用NAS，可以选择DIY自建，即自己购买硬件组装搭建NAS，NAS本质上也是一台计算机，只是在功能上偏向于存储而已，操作系统可以选择存储专用的FreeNAS的系统，也可以直接购买成品，诸如威联通、群晖、铁威马等。对于没有太多计算机基础的小伙伴，建议就不要自行搭建了，挑选硬件和系统容易交学费，故障排查繁琐。</p><p>个人之前用过铁威马，感觉是具备基础的NAS功能，如果只是想简单安全备份存储文件，铁威马确实够用了，性价比高。但就功能性和额外拓展的能力相比威联通和群晖，确实稍弱。鉴于本人使用NAS的目的，综合考虑后，购买了威联通的TS-873A。之前也考虑过价格相近的商用的机架式的NAS设备，诸如TS-832PXU，但企业级设备噪音较大，家用无法忍受。</p><p>选择TS-873A，我的核心诉求点如下：</p><ol><li><p>8盘位可提供足够的磁盘空间，组RAID10后还可以有热备磁盘位，未来很长一段时间内都不需要再升级设备。<br>如果4盘位，组建RAID10后是没有热备磁盘位的。另外，为什么不组RAID5的原因主要是，RAID10性能会更好些，万一出现故障恢复速度也快，RAID10虽然只能用一半的空间，但目前硬盘价格并不贵，其实是可以接受的。</p></li><li><p>内置 M.2 NVMe SSD 槽位，可利用SSD加速读写速度。<br>2个M.2 NVMe SSD，可以组RAID1，做读写缓存或者Qtier自动分层存储，大大加速读写速度，解决HDD硬盘较慢的问题。如果2个SSD插槽不够用，还可以再购买SSD扩展卡配件，873A有PCIe Gen3x4的插槽。</p></li><li><p>额外有2个PCIe Gen3x4插槽<br>可以安装额外的配件，诸如SSD扩展卡，万兆网卡等。我自己就买了25GbE的双口光纤网卡，原装是2个2.5G的电口网卡，大大提升了网络速度，让网络速度不再成为瓶颈点。不仅如此，加配件后可支持FC SAN环境。</p></li><li><p>价格合适，这点很重要<br>再往上，9盘位，高度过高，会占用机柜更多U的空间，12盘位又太贵。当然，就价格太贵什么的，完全不是对方的问题，是我的太穷的问题。</p></li><li><p>支持UPS</p></li><li><p>几乎没有什么噪音</p></li></ol><p>还有一些特性，我暂时用不着，诸如可扩充显卡，远程访问，搭建虚拟化环境等。可以访问<code>https://www.qnap.com.cn/zh-cn/product/ts-873a</code>看下官方的介绍。</p><h1 id="三、实际体验与改造"><a href="#三、实际体验与改造" class="headerlink" title="三、实际体验与改造"></a>三、实际体验与改造</h1><ol><li><p>外包装挺厚实的，保护机体用的泡沫也很大。机体自身挺沉的，大概15斤左右。机体下方有缓冲垫，如果你放在镜面的桌子上，或者机柜的托盘上，会有点粘在上面的感觉，不容易造成移动，拿起时需要先往上使点力。</p></li><li><p>拆开外壳，主板位于侧面，包括内存条，M2插槽。PCIe接口在上方，PCIe扩展体验不是非常好，空间不大，很小的螺丝刀才能正着伸进去，稍微大一点的螺丝刀就需要侧着拧。</p></li><li><p>我把内存升级了内存到32GB，原厂自带8GB内存有点小。hero系统比较吃内存，如果需要用hero的raid10，需要16GB以上。</p></li><li><p>加装了一块25GbE双端口的网卡，我买配件的时候，10G的刚好没货，才买的25G，事实上买10GbE的即可。</p></li><li><p>置入2块三星M2 NVMe SSD 970EVO Plus。这里要吐槽下威联通的SSD谜之兼容性。因为硬件本身也在升级，威联通并不会及时更新。比如，三星SSD的EVO 或者 EVO Plus 型号名称出现微小的变化，主要在型号后缀，可能会很难买到完全一模一样的型号。按照<code>https://www.qnap.com.cn/zh-cn/compatibility/?model=522&amp;category=ssd</code>官方的兼容性列表，威联通官方测试过，”970 EVO Plus MZ-V7S1T0” 和 “970 EVO MZ-V7E1T0BW” 是可兼容的，但事实上，目前能买到的”970 EVO Plus MZ-V7S1T0B” 我亲测是兼容的，但是 “970 EVO MZ-V7E1T0” 却又不兼容。不兼容的症状是会导致一些奇奇怪怪的问题，系统并不会提示什么，可以开机，机体上的指示灯也一切正常，就是实际运行不正常。</p></li><li><p>置入4块希捷银河ExosX18系列企业级氦气硬盘 ST16000NM000J 16TB 256MB 7200RPM。个人经验是，第一是硬盘的水很深，真的不要找不熟悉的渠道去购买特别低价的硬盘，老老实实找正规渠道买，第二是注意各种门的问题，可以去找下对应的型号并避开。我自己目前都买希捷的银河系列企业级的硬盘。</p></li></ol><h1 id="四、开始实验"><a href="#四、开始实验" class="headerlink" title="四、开始实验"></a>四、开始实验</h1><p>威联通NAS有两种系统，一种是传统的QTS，基于EXT4，另一种是 QuTS hero，基于ZFS。先说下结论，最终我还是用的QTS。虽然hero有许多高级特性，诸如去重，块大小可选等等，但对于我而言，稳定性更重要，高级功能虽然好但非必须，hero对机器性能的要求要远高于QTS，hero系统一旦初始设定完磁盘，就难以变更。虽然最终未使用hero系统，但我依然针对hero系统做了一系列的实际测试。</p><p>注意下，因为硬件所限，部分对照实验仅供参考，实验环境如下：</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>NAS与服务器均使用万兆电缆连接到交换机上，网络环境不成为速度瓶颈点</p><ol><li>8口10GbE万兆全SFP+光口交换机</li><li>10G万兆高速SFP+ DAC电缆</li></ol><h2 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h2><ol><li>HDD硬盘：4块 希捷银河ExosX18系列企业级氦气硬盘 ST16000NM000J 16TB 256MB 7200RPM</li><li>SSD硬盘：2块 三星M2 NVMe SSD 970EVO Plus</li><li>内存32GB，完全满足hero的要求，实验过程中，内存占有率均在50%以下。</li><li>25GbE网卡（可向下兼容10GbE），网络环境不成为瓶颈点。</li></ol><p>安装系统并创建存储池与区块LUN，开启iSCSI。安装好系统后，注意以下2点：</p><ol><li>组建RAID后，设置为服务优先。</li><li>在网络适配器选项卡处，给使用的网卡设定固定IPv4地址，巨帧封包设定为最大的9000，关闭IPv6，关闭FEC。</li></ol><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ol><li>硬件配置是 AMD Ryzen7 3800X 内存128GB</li><li>单独一块SATA SSD用于安装ESXi 7.0</li><li>在一块服务器本地HDD硬盘上，创建win10虚拟机，分配8核32GB内存，HDD型号是 希捷银河Exos7E8系列企业级硬盘 ST8000NM000A 8TB 256MB 7200RPM</li><li>主板上安装有一块三星M2 NVMe SSD 970 EVO MZ-V7E1T0</li><li>网卡是Intel 82599芯片 10G万兆SFP+光纤网卡</li></ol><p>服务器上还做了以下设置：</p><ol><li>ESXi网络的标准交换机，设定MTU为9000，win10的网卡属性，设置开启巨帧Jumbo Packet</li><li>按照<code>https://www.ibm.com/docs/zh/sanvolumecontroller/8.3.x?topic=problem-iscsi-performance-analysis-tuning</code>，禁用ESXi和win10上的TCP延迟应答功能，并开启iSCSI巨帧。</li></ol><h2 id="测试软件"><a href="#测试软件" class="headerlink" title="测试软件"></a>测试软件</h2><p>使用CrystalDiskMark 6.0.2 x64版本。测试次数选5，大小32GiB，测试队列数与线程数使用默认项，分别是顺序写入Q32T1、随机4K Q8T8、随机4K Q32T1、随机4K Q1T1</p><h2 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h2><ul><li>所有磁盘传输速度单位均是 MB&#x2F;s</li><li>由于10G网络限制，部分测试项，特别是顺序读，已经达到网络传输速率上限，造成无法有效测量真实IO速度</li><li>多次重复测量，数值可能会有变化，变化幅度最大在15%左右。</li></ul><p>测试维度有：</p><ol><li>NAS操作系统，分别是 QTS系统和QuTS hero系统</li><li>磁盘类型，分别是 M2 NVMe SSD 和 HDD</li><li>RAID类型，针对 0，1，5，10 进行测试，其中SSD仅测试RAID1。</li><li>加速方式，针对不开启、高速缓存加速、Qtier三种方式进行测试，hero只有高速缓存加速功能。</li><li>连接方式，分别是使用win10直连iSCSI和使用vmware通过iSCSI连接后创建存储空间配置给win10虚拟机用。</li><li>块大小，QTS和QuTS hero的选项不同，QTS选项是512Bytes和4KB，hero是32k(vmware)，64k（Hybrid），128k（视频&#x2F;大型文件&#x2F;备份）。但QTS LUN 4KB块大小，vmware通过iSCSI无法识别到，但win10通过iSCSI正常识别。</li><li>同步I&#x2F;O，ZFS Intent Log (ZIL) 同步设置，仅hero有这个选项</li></ol><p>缩写：</p><ol><li>操作系统，QuTS hero 缩写为 hero</li><li>磁盘类型，M2 NVMe SSD 缩写为 M2 SSD</li><li>连接渠道，win10直连iSCSI缩写为 win10 ，使用vmware通过iSCSI连接后配置缩写为 vm</li></ol><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><h3 id="对比-QTS-系统-和-QuTS-hero-系统的磁盘速度"><a href="#对比-QTS-系统-和-QuTS-hero-系统的磁盘速度" class="headerlink" title="对比 QTS 系统 和 QuTS hero 系统的磁盘速度"></a>对比 QTS 系统 和 QuTS hero 系统的磁盘速度</h3><p>测试环境：</p><ol><li>不开启加速，不使用Qtier</li><li>全部使用win10通过iSCSI方式连接NAS</li><li>QTS系统块大小统一设置512Bytes，hero系统块大小统一设置64K</li><li>QTS系统无ZIL同步IO配置，hero系统ZIL同步IO设置为不使用，本机磁盘无此项配置</li></ol><table><thead><tr><th align="left">系统类型</th><th align="right">QTS</th><th align="right">hero</th><th align="right">QTS</th><th align="right">hero</th><th align="right">QTS</th><th align="right">hero</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td></tr><tr><td align="left">RAID类型</td><td align="right">无</td><td align="right">无</td><td align="right">RAID 0</td><td align="right">RAID 0</td><td align="right">RAID 1</td><td align="right">RAID 1</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1210</td><td align="right">1237</td><td align="right">1233</td><td align="right">1237</td><td align="right">1235</td><td align="right">1237</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">711</td><td align="right">704</td><td align="right">1196</td><td align="right">989</td><td align="right">715</td><td align="right">763</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">307</td><td align="right">272</td><td align="right">308</td><td align="right">346</td><td align="right">307</td><td align="right">352</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">278</td><td align="right">25</td><td align="right">333</td><td align="right">38</td><td align="right">280</td><td align="right">34</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">350</td><td align="right">361</td><td align="right">353</td><td align="right">382</td><td align="right">368</td><td align="right">391</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">249</td><td align="right">32</td><td align="right">264</td><td align="right">71</td><td align="right">258</td><td align="right">42</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">15</td><td align="right">18</td><td align="right">15</td><td align="right">18</td><td align="right">15</td><td align="right">21</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">21</td><td align="right">7.1</td><td align="right">20</td><td align="right">8.6</td><td align="right">20</td><td align="right">6.8</td></tr></tbody></table><table><thead><tr><th align="left">系统类型</th><th align="right">QTS</th><th align="right">hero</th><th align="right">QTS</th><th align="right">hero</th><th align="right">QTS</th><th align="right">hero</th><th align="right">QTS</th><th align="right">hero</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td></tr><tr><td align="left">RAID类型</td><td align="right">无</td><td align="right">无</td><td align="right">RAID 0</td><td align="right">RAID 0</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 10</td><td align="right">RAID 10</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1209</td><td align="right">965</td><td align="right">1222</td><td align="right">958</td><td align="right">934</td><td align="right">941</td><td align="right">1228</td><td align="right">1190</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">293</td><td align="right">259</td><td align="right">531</td><td align="right">293</td><td align="right">285</td><td align="right">312</td><td align="right">539</td><td align="right">534</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">276</td><td align="right">40</td><td align="right">279</td><td align="right">67</td><td align="right">218</td><td align="right">67</td><td align="right">306</td><td align="right">103</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">17</td><td align="right">17</td><td align="right">60</td><td align="right">18</td><td align="right">13</td><td align="right">18</td><td align="right">47</td><td align="right">27</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">259</td><td align="right">43</td><td align="right">215</td><td align="right">69</td><td align="right">217</td><td align="right">67</td><td align="right">357</td><td align="right">100</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">33</td><td align="right">14</td><td align="right">56</td><td align="right">17</td><td align="right">28</td><td align="right">17</td><td align="right">54</td><td align="right">25</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">15</td><td align="right">21</td><td align="right">16</td><td align="right">21</td><td align="right">16</td><td align="right">20</td><td align="right">15</td><td align="right">19</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">21</td><td align="right">14</td><td align="right">21</td><td align="right">13</td><td align="right">18</td><td align="right">14</td><td align="right">20</td><td align="right">14</td></tr></tbody></table><ol><li>顺序读写场景，两个系统的IO性能差异较小</li><li>不管是磁盘类型是SSD还是HDD，hero系统的随机4K文件IO性能都低于QTS</li></ol><h3 id="实测-M2-NVMe-SSD-与-HDD-的速度"><a href="#实测-M2-NVMe-SSD-与-HDD-的速度" class="headerlink" title="实测 M2 NVMe SSD 与 HDD 的速度"></a>实测 M2 NVMe SSD 与 HDD 的速度</h3><p>测试环境：</p><ol><li>统一不使用RAID</li><li>不开启加速，不使用Qtier</li><li>全部使用win10通过iSCSI方式连接NAS</li><li>QTS系统块大小统一设置512Bytes，hero系统块大小统一设置64K</li><li>QTS系统无ZIL同步IO配置，hero系统ZIL同步IO设置为不使用，本机磁盘无此项配置</li></ol><table><thead><tr><th align="left">磁盘类型</th><th align="right">本机 M2 SSD</th><th align="right">M2 SSD</th><th align="right">M2 SSD</th><th align="right">本机 HDD</th><th align="right">HDD</th><th align="right">HDD</th></tr></thead><tbody><tr><td align="left">系统类型</td><td align="right">略</td><td align="right">QTS</td><td align="right">hero</td><td align="right">略</td><td align="right">QTS</td><td align="right">hero</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">3550</td><td align="right">1210</td><td align="right">1237</td><td align="right">222</td><td align="right">1209</td><td align="right">965</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">1913</td><td align="right">711</td><td align="right">704</td><td align="right">199</td><td align="right">293</td><td align="right">259</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">878</td><td align="right">307</td><td align="right">272</td><td align="right">1.32</td><td align="right">276</td><td align="right">40</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">900</td><td align="right">278</td><td align="right">25</td><td align="right">20</td><td align="right">17</td><td align="right">17</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">425</td><td align="right">350</td><td align="right">361</td><td align="right">1.37</td><td align="right">259</td><td align="right">43</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">328</td><td align="right">249</td><td align="right">32</td><td align="right">12</td><td align="right">33</td><td align="right">14</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">39</td><td align="right">15</td><td align="right">18</td><td align="right">0.41</td><td align="right">15</td><td align="right">21</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">97</td><td align="right">21</td><td align="right">7.1</td><td align="right">16</td><td align="right">21</td><td align="right">14</td></tr></tbody></table><h3 id="实测-RAID-0，1，5，10"><a href="#实测-RAID-0，1，5，10" class="headerlink" title="实测 RAID 0，1，5，10"></a>实测 RAID 0，1，5，10</h3><p>测试环境：</p><ol><li>NAS安装QTS系统</li><li>不开启加速，不使用Qtier</li><li>全部使用win10通过iSCSI方式连接NAS</li><li>QTS系统块大小统一设置512Bytes</li><li>QTS系统无ZIL同步IO配置</li></ol><table><thead><tr><th align="left">RAID类型</th><th align="right">无</th><th align="right">RAID 0</th><th align="right">RAID 1</th><th align="right">无</th><th align="right">RAID 0</th><th align="right">RAID 1</th><th align="right">RAID 5</th><th align="right">RAID 10</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1210</td><td align="right">1233</td><td align="right">1235</td><td align="right">1209</td><td align="right">1222</td><td align="right">1210</td><td align="right">1224</td><td align="right">1228</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">711</td><td align="right">1196</td><td align="right">715</td><td align="right">293</td><td align="right">531</td><td align="right">280</td><td align="right">455</td><td align="right">539</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">307</td><td align="right">308</td><td align="right">307</td><td align="right">276</td><td align="right">279</td><td align="right">278</td><td align="right">287</td><td align="right">306</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">278</td><td align="right">333</td><td align="right">280</td><td align="right">17</td><td align="right">60</td><td align="right">16</td><td align="right">28</td><td align="right">47</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">350</td><td align="right">353</td><td align="right">368</td><td align="right">259</td><td align="right">215</td><td align="right">211</td><td align="right">226</td><td align="right">357</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">249</td><td align="right">264</td><td align="right">258</td><td align="right">33</td><td align="right">56</td><td align="right">32</td><td align="right">23</td><td align="right">54</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">15</td><td align="right">15</td><td align="right">15</td><td align="right">15</td><td align="right">16</td><td align="right">16</td><td align="right">16</td><td align="right">15</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">21</td><td align="right">20</td><td align="right">20</td><td align="right">21</td><td align="right">21</td><td align="right">21</td><td align="right">22</td><td align="right">20</td></tr></tbody></table><h3 id="QTS系统中，对比高速缓存加速与Qtier的读写速度"><a href="#QTS系统中，对比高速缓存加速与Qtier的读写速度" class="headerlink" title="QTS系统中，对比高速缓存加速与Qtier的读写速度"></a>QTS系统中，对比高速缓存加速与Qtier的读写速度</h3><p>测试环境：</p><ol><li>NAS安装QTS系统</li><li>高速缓存和Qtier高速层均设置RAID 1读写缓存</li><li>QTS系统块大小统一设置512Bytes</li><li>QTS系统无ZIL同步IO配置</li></ol><table><thead><tr><th align="left">加速方式</th><th align="right">不开启</th><th align="right">不开启</th><th align="right">高速缓存</th><th align="right">高速缓存</th><th align="right">Qtier</th><th align="right">Qtier</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD+SSD</td><td align="right">HDD+SSD</td><td align="right">HDD+SSD</td><td align="right">HDD+SSD</td></tr><tr><td align="left">连接渠道</td><td align="right">win10</td><td align="right">vm</td><td align="right">win10</td><td align="right">vm</td><td align="right">win10</td><td align="right">vm</td></tr><tr><td align="left">RAID类型</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 1</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">934</td><td align="right">900</td><td align="right">1233</td><td align="right">955</td><td align="right">1235</td><td align="right">950</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">285</td><td align="right">278</td><td align="right">718</td><td align="right">708</td><td align="right">286</td><td align="right">280</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">218</td><td align="right">225</td><td align="right">299</td><td align="right">420</td><td align="right">311</td><td align="right">360</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">13</td><td align="right">37</td><td align="right">234</td><td align="right">256</td><td align="right">13</td><td align="right">28</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">217</td><td align="right">139</td><td align="right">242</td><td align="right">314</td><td align="right">337</td><td align="right">269</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">28</td><td align="right">28</td><td align="right">233</td><td align="right">244</td><td align="right">17</td><td align="right">16</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">16</td><td align="right">33</td><td align="right">18</td><td align="right">35</td><td align="right">15</td><td align="right">33</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">18</td><td align="right">30</td><td align="right">21</td><td align="right">32</td><td align="right">21</td><td align="right">25</td></tr></tbody></table><table><thead><tr><th align="left">加速方式</th><th align="right">不开启</th><th align="right">不开启</th><th align="right">高速缓存</th><th align="right">高速缓存</th><th align="right">Qtier</th><th align="right">Qtier</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD+SSD</td><td align="right">HDD+SSD</td><td align="right">HDD+SSD</td><td align="right">HDD+SSD</td></tr><tr><td align="left">连接渠道</td><td align="right">win10</td><td align="right">vm</td><td align="right">win10</td><td align="right">vm</td><td align="right">win10</td><td align="right">vm</td></tr><tr><td align="left">RAID类型</td><td align="right">RAID 10</td><td align="right">RAID 10</td><td align="right">RAID 10</td><td align="right">RAID 10</td><td align="right">RAID 10</td><td align="right">RAID 10</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1228</td><td align="right">942</td><td align="right">1214</td><td align="right">930</td><td align="right">1232</td><td align="right">916</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">539</td><td align="right">536</td><td align="right">719</td><td align="right">702</td><td align="right">508</td><td align="right">508</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">306</td><td align="right">326</td><td align="right">366</td><td align="right">415</td><td align="right">301</td><td align="right">380</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">47</td><td align="right">45</td><td align="right">180</td><td align="right">256</td><td align="right">59</td><td align="right">26</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">357</td><td align="right">233</td><td align="right">382</td><td align="right">312</td><td align="right">241</td><td align="right">301</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">54</td><td align="right">55</td><td align="right">240</td><td align="right">242</td><td align="right">26</td><td align="right">27</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">15</td><td align="right">34</td><td align="right">17</td><td align="right">31</td><td align="right">17</td><td align="right">33</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">20</td><td align="right">32</td><td align="right">18</td><td align="right">29</td><td align="right">22</td><td align="right">32</td></tr></tbody></table><p>高速缓存加速是利用SSD作为缓存用于改进NAS的读写性能，加速分3种，只读加速、只写加速、读写加速。加速用的SSD，RAID可选项有不启用，RAID 0，1，5，6，10。只读加速可以组RAID0，因为并不存在数据丢失风险，RAID 0 是最优选项。只写或者读写缓存，建议使用RAID 1，5，6，10，避免因为SSD本身故障导致数据丢失或损坏的情况。高速缓存加速读的原理是，当从LUN或卷读取数据时，QTS将数据复制到SSD缓存以加速未来的读取请求。加速写的原理是QTS先将传入数据写入SSD缓存，然后再将数据刷新到常规存储。如果新数据在缓存中，对新数据的读取访问也会加速。</p><p>Qtier简单描述就是，QTS系统会根据存储设备速度将存储进行分层，然后按照数据访问频率，再各层之间移动数据。将经常访问的数据移动到最快速的磁盘，以提高读写性能，并将不常访问的数据移动到大容量的磁盘，降低存储成本。</p><ul><li>Seq Q32T1 Read，无论是RAID 1 还是10，有无开缓存，都基本触及或接近10G网络的速度上限。  </li><li>Seq Q32T1 Write，不开启缓存，基本和RAID 1 和 RAID 10 实际速度接近，高速缓存加速的写速度其实就是SSD的写入速度，和高速缓存原理的描述一致。Qtier的写入，RAID 1 和 10 接近2倍的差异，而且和HDD写入速度接近，猜测应该是直接写到HDD磁盘上的。</li><li>4KB Q8T8  Read，速度差异小。</li><li>4KB Q8T8  Write，Qtier和不开启加速的速度是接近的，高速缓存速度是最快的。</li><li>4KB Q32T1 Read，速度也相对较小。</li><li>4KB Q32T1 Write，不开启加速和开启高速缓存的结果和预期的一致，高速缓存的写速预期是应该和写入SSD 的 RAID 1 速度差不多，测试结果相近。但Qtier性能较差，甚至比不开启加速的速度更低，我甚至一度怀疑我测试有问题，特意多次测量，但结果依然不佳，这点让我不是很理解。</li><li>4KB Q1T1  Read，速度差异小。</li><li>4KB Q1T1  Write，不论什么RAID类型，是否开启加速，速度差异都不大。</li></ul><p>从实验结果看，顺序读取由于触及网络上限，可能真实速度还可以再更快一些，毕竟 安装在本地的 M2 SSD 顺序读取都可以到 3500 MB&#x2F;s 这样的速度了。关于顺序文件写入，由于Qtier是直接写入到HDD，所以速度比较低。关于4K文件的读，速度大抵和预期的差不多，高速缓存的速度和做RAID 1的SSD读速相近，Qtier和 做 RAID 10 的 HDD 读速相近。而在写性能方面，特别是在随机并行写入的场景下，高速缓存优势明显。虽然所有涉及Qiter的测试，在测试前我已经把相关的LUN设置为Qiter必做分层的LUN了，且手动执行了分层优化的任务，但因为我的实验场景是随机数据写入，所以从实验结果上看，Qtier优势不大，真实场景下性能应该会好一些。</p><p>总之，如果是有很多随机小文件读写的场景，诸如虚拟化等，用高速缓存加速更合适。而Qtier，更适合IO可预测的场景，诸如文件服务器等。</p><h3 id="QTS-系统中，LUN不同大小的块的速度"><a href="#QTS-系统中，LUN不同大小的块的速度" class="headerlink" title="QTS 系统中，LUN不同大小的块的速度"></a>QTS 系统中，LUN不同大小的块的速度</h3><p>测试环境：</p><ol><li>NAS安装QTS系统</li><li>不开启加速，不使用Qtier</li><li>全部使用win10通过iSCSI方式连接NAS</li><li>没有ZIL同步配置项</li></ol><table><thead><tr><th align="left">磁盘类型</th><th align="right">M2 SSD</th><th align="right">M2 SSD</th><th align="right">M2 SSD</th><th align="right">M2 SSD</th><th align="right">M2 SSD</th><th align="right">M2 SSD</th></tr></thead><tbody><tr><td align="left">RAID类型</td><td align="right">无</td><td align="right">无</td><td align="right">RAID 0</td><td align="right">RAID 0</td><td align="right">RAID 1</td><td align="right">RAID 1</td></tr><tr><td align="left">块大小</td><td align="right">512 B</td><td align="right">4 KB</td><td align="right">512 B</td><td align="right">4 KB</td><td align="right">512 B</td><td align="right">4 KB</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1210</td><td align="right">1217</td><td align="right">1233</td><td align="right">1235</td><td align="right">1235</td><td align="right">1232</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">711</td><td align="right">717</td><td align="right">1196</td><td align="right">1229</td><td align="right">715</td><td align="right">716</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">307</td><td align="right">310</td><td align="right">308</td><td align="right">301</td><td align="right">307</td><td align="right">299</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">278</td><td align="right">313</td><td align="right">333</td><td align="right">292</td><td align="right">280</td><td align="right">293</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">350</td><td align="right">358</td><td align="right">353</td><td align="right">244</td><td align="right">368</td><td align="right">341</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">249</td><td align="right">248</td><td align="right">264</td><td align="right">240</td><td align="right">258</td><td align="right">251</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">15</td><td align="right">15</td><td align="right">15</td><td align="right">18</td><td align="right">15</td><td align="right">16</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">21</td><td align="right">22</td><td align="right">20</td><td align="right">21</td><td align="right">20</td><td align="right">20</td></tr></tbody></table><table><thead><tr><th align="left">磁盘类型</th><th align="right">HDD</th><th align="right">HDD</th><th align="right">HDD</th><th align="right">HDD</th><th align="right">HDD</th><th align="right">HDD</th><th align="right">HDD</th><th align="right">HDD</th></tr></thead><tbody><tr><td align="left">RAID类型</td><td align="right">无</td><td align="right">无</td><td align="right">RAID 0</td><td align="right">RAID 0</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 10</td><td align="right">RAID 10</td></tr><tr><td align="left">块大小</td><td align="right">512 B</td><td align="right">4 KB</td><td align="right">512 B</td><td align="right">4 KB</td><td align="right">512 B</td><td align="right">4 KB</td><td align="right">512 B</td><td align="right">4 KB</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1209</td><td align="right">944</td><td align="right">1222</td><td align="right">1234</td><td align="right">934</td><td align="right">1186</td><td align="right">1228</td><td align="right">1221</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">293</td><td align="right">280</td><td align="right">531</td><td align="right">534</td><td align="right">285</td><td align="right">266</td><td align="right">539</td><td align="right">525</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">276</td><td align="right">61</td><td align="right">279</td><td align="right">295</td><td align="right">218</td><td align="right">304</td><td align="right">306</td><td align="right">353</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">17</td><td align="right">16</td><td align="right">60</td><td align="right">60</td><td align="right">13</td><td align="right">19</td><td align="right">47</td><td align="right">58</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">259</td><td align="right">70</td><td align="right">215</td><td align="right">229</td><td align="right">217</td><td align="right">312</td><td align="right">357</td><td align="right">324</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">33</td><td align="right">26</td><td align="right">56</td><td align="right">56</td><td align="right">28</td><td align="right">30</td><td align="right">54</td><td align="right">46</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">15</td><td align="right">16</td><td align="right">16</td><td align="right">16</td><td align="right">16</td><td align="right">16</td><td align="right">15</td><td align="right">15</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">21</td><td align="right">21</td><td align="right">21</td><td align="right">21</td><td align="right">18</td><td align="right">20</td><td align="right">20</td><td align="right">22</td></tr></tbody></table><p>QTS系统中，针对不同的块大小，即使是在不同RAID场景下，并没有显著的性能区别。</p><h3 id="QuTS-hero-系统中，LUN不同大小的块的速度"><a href="#QuTS-hero-系统中，LUN不同大小的块的速度" class="headerlink" title="QuTS hero 系统中，LUN不同大小的块的速度"></a>QuTS hero 系统中，LUN不同大小的块的速度</h3><p>测试环境：</p><ol><li>NAS安装QuTS hero 系统</li><li>不开启加速，不使用Qtier</li><li>全部使用win10通过iSCSI方式连接NAS</li><li>ZIL同步IO设置为不使用</li></ol><table><thead><tr><th align="left">块大小</th><th align="right">32 KB</th><th align="right">64 KB</th><th align="right">128 KB</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td></tr><tr><td align="left">RAID类型</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 1</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1234</td><td align="right">1237</td><td align="right">1236</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">697</td><td align="right">763</td><td align="right">708</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">339</td><td align="right">352</td><td align="right">250</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">75</td><td align="right">34</td><td align="right">21</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">399</td><td align="right">391</td><td align="right">211</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">80</td><td align="right">42</td><td align="right">21</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">21</td><td align="right">21</td><td align="right">18</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">9.4</td><td align="right">6.8</td><td align="right">5.9</td></tr></tbody></table><table><thead><tr><th align="left">块大小</th><th align="right">32 KB</th><th align="right">64 KB</th><th align="right">128 KB</th><th align="right">32 KB</th><th align="right">64 KB</th><th align="right">128 KB</th><th align="right">32 KB</th><th align="right">64 KB</th><th align="right">128 KB</th></tr></thead><tbody><tr><td align="left">RAID类型</td><td align="right">RAID 0</td><td align="right">RAID 0</td><td align="right">RAID 0</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 1</td><td align="right">RAID 10</td><td align="right">RAID 10</td><td align="right">RAID 10</td></tr><tr><td align="left">磁盘类型</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">925</td><td align="right">958</td><td align="right">957</td><td align="right">907</td><td align="right">941</td><td align="right">960</td><td align="right">1205</td><td align="right">1190</td><td align="right">1208</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">294</td><td align="right">293</td><td align="right">288</td><td align="right">318</td><td align="right">312</td><td align="right">249</td><td align="right">473</td><td align="right">534</td><td align="right">528</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">68</td><td align="right">67</td><td align="right">58</td><td align="right">65</td><td align="right">67</td><td align="right">55</td><td align="right">107</td><td align="right">103</td><td align="right">88</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">25</td><td align="right">18</td><td align="right">10</td><td align="right">26</td><td align="right">18</td><td align="right">9.0</td><td align="right">47</td><td align="right">27</td><td align="right">15</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">68</td><td align="right">69</td><td align="right">60</td><td align="right">67</td><td align="right">67</td><td align="right">58</td><td align="right">98</td><td align="right">100</td><td align="right">85</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">25</td><td align="right">17</td><td align="right">10</td><td align="right">26</td><td align="right">17</td><td align="right">8.9</td><td align="right">43</td><td align="right">25</td><td align="right">14</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">19</td><td align="right">21</td><td align="right">19</td><td align="right">19</td><td align="right">20</td><td align="right">21</td><td align="right">19</td><td align="right">19</td><td align="right">20</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">14</td><td align="right">13</td><td align="right">10</td><td align="right">13</td><td align="right">14</td><td align="right">9.0</td><td align="right">14</td><td align="right">14</td><td align="right">14</td></tr></tbody></table><p>和QTS系统相同的是，Quts hero系统顺序读写，小文件随机读，性能差异不大。但随机写小文件场景下，不同块大小的速度，写性能差异较大。</p><h3 id="QuTS-hero-系统中，对比ZIL同步设置对磁盘性能的影响"><a href="#QuTS-hero-系统中，对比ZIL同步设置对磁盘性能的影响" class="headerlink" title="QuTS hero 系统中，对比ZIL同步设置对磁盘性能的影响"></a>QuTS hero 系统中，对比ZIL同步设置对磁盘性能的影响</h3><p>测试环境：</p><ol><li>NAS安装QuTS hero 系统</li><li>不开启加速，不使用Qtier</li><li>全部使用win10通过iSCSI方式连接NAS</li><li>QuTS hero系统块大小统一设置64K</li></ol><table><thead><tr><th align="left">ZIL同步设置</th><th align="right">不使用</th><th align="right">始终</th><th align="right">不使用</th><th align="right">始终</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td><td align="right">M2 SSD</td></tr><tr><td align="left">RAID类型</td><td align="right">无</td><td align="right">无</td><td align="right">RAID 0</td><td align="right">RAID 0</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">1237</td><td align="right">1222</td><td align="right">1237</td><td align="right">1236</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">704</td><td align="right">219</td><td align="right">989</td><td align="right">322</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">272</td><td align="right">247</td><td align="right">346</td><td align="right">351</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">25</td><td align="right">17</td><td align="right">38</td><td align="right">22</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">361</td><td align="right">332</td><td align="right">382</td><td align="right">390</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">32</td><td align="right">13</td><td align="right">71</td><td align="right">15</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">18</td><td align="right">18</td><td align="right">18</td><td align="right">21</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">7.1</td><td align="right">1.9</td><td align="right">8.6</td><td align="right">2.4</td></tr></tbody></table><table><thead><tr><th align="left">ZIL同步设置</th><th align="right">不使用</th><th align="right">始终</th><th align="right">不使用</th><th align="right">始终</th><th align="right">不使用</th><th align="right">始终</th></tr></thead><tbody><tr><td align="left">磁盘类型</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td><td align="right">HDD</td></tr><tr><td align="left">RAID类型</td><td align="right">无</td><td align="right">无</td><td align="right">RAID 0</td><td align="right">RAID 0</td><td align="right">RAID 10</td><td align="right">RAID 10</td></tr><tr><td align="left">Seq Q32T1 Read</td><td align="right">965</td><td align="right">946</td><td align="right">958</td><td align="right">1013</td><td align="right">1190</td><td align="right">1209</td></tr><tr><td align="left">Seq Q32T1 Write</td><td align="right">259</td><td align="right">32</td><td align="right">293</td><td align="right">37</td><td align="right">534</td><td align="right">50</td></tr><tr><td align="left">4KB Q8T8  Read</td><td align="right">40</td><td align="right">38</td><td align="right">67</td><td align="right">64</td><td align="right">103</td><td align="right">99</td></tr><tr><td align="left">4KB Q8T8  Write</td><td align="right">17</td><td align="right">2.5</td><td align="right">18</td><td align="right">3</td><td align="right">27</td><td align="right">4.3</td></tr><tr><td align="left">4KB Q32T1 Read</td><td align="right">43</td><td align="right">41</td><td align="right">69</td><td align="right">65</td><td align="right">100</td><td align="right">83</td></tr><tr><td align="left">4KB Q32T1 Write</td><td align="right">14</td><td align="right">1.7</td><td align="right">17</td><td align="right">2</td><td align="right">25</td><td align="right">2.7</td></tr><tr><td align="left">4KB Q1T1  Read</td><td align="right">21</td><td align="right">20</td><td align="right">21</td><td align="right">20</td><td align="right">19</td><td align="right">21</td></tr><tr><td align="left">4KB Q1T1  Write</td><td align="right">14</td><td align="right">0.40</td><td align="right">13</td><td align="right">0.42</td><td align="right">14</td><td align="right">0.45</td></tr></tbody></table><p>实测证明，ZIL对性能影响非常大，2个数量级的性能差异，非必要应尽量不开启ZIL。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、为什么要NAS？&quot;&gt;&lt;a href=&quot;#一、为什么要NAS？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要NAS？&quot;&gt;&lt;/a&gt;一、为什么要NAS？&lt;/h1&gt;&lt;p&gt;虽然每个人都有各自的理由，但核心诉求点集中在安全存储和备份分享数据，支持远程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>极简Prometheus监控实战</title>
    <link href="https://fenixadar.github.io/2022/08/04/%E6%9E%81%E7%AE%80Prometheus%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98/"/>
    <id>https://fenixadar.github.io/2022/08/04/%E6%9E%81%E7%AE%80Prometheus%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98/</id>
    <published>2022-08-04T02:47:39.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言与目录"><a href="#一、前言与目录" class="headerlink" title="一、前言与目录"></a>一、前言与目录</h1><p>监控是当前云原生时代下可观测性中关键性的一环，较之前相比，云原生时代已经发生了诸多变化，诸如微服务，容器化等技术层出不穷，且云原生时代的演进速度，更新速度极快，相对应监控所产生的数据量大大增加，对实时性的要求也大大增加。为应对变化，Prometheus应运而生，其所可实现的功能，与云原生极好的契合度，集成第三方开源组件的便利性，无疑使其成为无疑是最为耀眼的明星之一。</p><p>本文着重在于介绍如何利用Prometheus搭建监控系统，涵盖探针，指标设定，可视化，告警设定，容器监控等。这是一篇入门级教程，暂不涵盖gateway，K8S集群等的相关内容。关于Prometheus的基本知识与概念，自行google之，本文重点描述实战过程。</p><p>目录：</p><ol><li>部署Prometheus Server</li><li>部署监控探针</li><li>部署Grafana</li><li>部署AlertManager</li><li>部署PrometheusAlert</li><li>配置告警规则</li></ol><h1 id="二、部署Prometheus-Server"><a href="#二、部署Prometheus-Server" class="headerlink" title="二、部署Prometheus Server"></a>二、部署Prometheus Server</h1><p>本节主要介绍以docker的方式部署Prometheus Server，并预留映射相关配置项</p><h2 id="2-1-配置环境"><a href="#2-1-配置环境" class="headerlink" title="2.1 配置环境"></a>2.1 配置环境</h2><ol><li>创建文件夹并授予权限<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -pv /data/docker/prometheus/&#123;data,alert_rules,job&#125;</span><br><span class="line">sudo chown -R myusername:myusername /data/docker/prometheus/</span><br></pre></td></tr></table></figure>其中,</li></ol><ul><li>data文件夹用于存放prometheus产生的数据</li><li>alert_rules文件夹用于存放prometheus alert告警规则配置文件</li><li>job用于存放监控对象配置json文件</li><li>myusername可替换为实际的用户名</li></ul><ol start="2"><li><p>执行本条命令以避免出现 permission denied 错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown 65534:65534 -R /data/docker/prometheus/data</span><br></pre></td></tr></table></figure></li><li><p>拷贝配置文件到指定的目录，注意下，需要关注该文件中涉及“$ip”的部分，后续配置，诸如添加AlertManager后，记得返回修改修改此处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"># my global config</span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line">  # scrape_timeout is set to the global default (10s).</span><br><span class="line"></span><br><span class="line"># Alertmanager configuration</span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    # - targets: [&quot;$ip:9093&quot;]</span><br><span class="line">      # - alertmanager:9093</span><br><span class="line"></span><br><span class="line"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br><span class="line">rule_files:</span><br><span class="line">  # - &quot;first_rules.yml&quot;</span><br><span class="line">  # - &quot;second_rules.yml&quot;</span><br><span class="line">  - /etc/prometheus/alert_rules/*.rules</span><br><span class="line"></span><br><span class="line"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="line"># Here it&#x27;s Prometheus itself.</span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/prometheus.json</span><br><span class="line">      refresh_interval: 1m  # 重载配置文件</span><br><span class="line"></span><br><span class="line">  # Node 主机组</span><br><span class="line">  - job_name: &#x27;host&#x27;</span><br><span class="line">    #basic_auth:</span><br><span class="line">    #  username: prometheus</span><br><span class="line">    #  password: prometheus</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/host.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line"></span><br><span class="line">  # cadvisor 容器组</span><br><span class="line">  - job_name: &#x27;cadvisor&#x27;</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/cadvisor.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line"></span><br><span class="line">  # mysql exporter 组</span><br><span class="line">  - job_name: &#x27;mysqld-exporter&#x27;</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/mysqld-exporter.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line"></span><br><span class="line">  # blackbox ping 组</span><br><span class="line">  - job_name: &#x27;blackbox_ping&#x27;</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line">    scrape_timeout: 2s</span><br><span class="line">    metrics_path: /probe</span><br><span class="line">    params:</span><br><span class="line">      module: [ping]</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/blackbox/ping/*.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line">    relabel_configs:</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: $ip:9115</span><br><span class="line"></span><br><span class="line">  # blackbox http get 2xx 组</span><br><span class="line">  - job_name: &#x27;blackbox_http_2xx&#x27;</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line">    metrics_path: /probe</span><br><span class="line">    params:</span><br><span class="line">      module: [http_2xx]</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/blackbox/http_2xx/*.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line">    relabel_configs:</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: $ip:9115</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;blackbox_tcp&quot;</span><br><span class="line">    metrics_path: /probe</span><br><span class="line">    params:</span><br><span class="line">      module: [tcp_connect]</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/blackbox/tcp/*.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line">    relabel_configs:</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: $ip:9115</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;blackbox_ssh_banner&#x27;</span><br><span class="line">    metrics_path: /probe</span><br><span class="line">    params:</span><br><span class="line">      module: [ssh_banner]</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/blackbox/ssh_banner/*.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line">    relabel_configs:</span><br><span class="line">      # Ensure port is 22, pass as URL parameter</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        regex: (.*?)(:.*)?</span><br><span class="line">        replacement: $&#123;1&#125;:22</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      # Make instance label the target</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      # Actually talk to the blackbox exporter though</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: $ip:9115</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;blackbox_dns&quot;</span><br><span class="line">    metrics_path: /probe</span><br><span class="line">    params:</span><br><span class="line">      module: [dns_udp]</span><br><span class="line">    file_sd_configs:</span><br><span class="line">    - files:</span><br><span class="line">      - /etc/prometheus/job/blackbox/dns/*.json</span><br><span class="line">      refresh_interval: 1m</span><br><span class="line">    relabel_configs:</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: $ip:9115</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-启动服务端"><a href="#2-2-启动服务端" class="headerlink" title="2.2 启动服务端"></a>2.2 启动服务端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd  \</span><br><span class="line">  -p 9090:9090 \</span><br><span class="line">  -v /data/docker/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro \</span><br><span class="line">  -v /data/docker/prometheus/alert_rules:/etc/prometheus/alert_rules \</span><br><span class="line">  -v /data/docker/prometheus/job:/etc/prometheus/job \</span><br><span class="line">  -v /data/docker/prometheus/data:/data/prometheus/ \</span><br><span class="line">  -v /etc/timezone:/etc/timezone:ro \</span><br><span class="line">  -v /etc/localtime:/etc/localtime:ro \</span><br><span class="line">  --name prometheus \</span><br><span class="line">  --restart=always \</span><br><span class="line">  prom/prometheus:v2.28.1 \</span><br><span class="line">  --config.file=/etc/prometheus/prometheus.yml  \</span><br><span class="line">  --storage.tsdb.path=/data/prometheus/ \</span><br><span class="line">  --storage.tsdb.retention.time=30d \</span><br><span class="line">  --web.read-timeout=5m \</span><br><span class="line">  --web.max-connections=10 \</span><br><span class="line">  --query.max-concurrency=20 \</span><br><span class="line">  --query.timeout=2m \</span><br><span class="line">  --web.enable-lifecycle</span><br></pre></td></tr></table></figure><p>启动成功后，通过浏览器访问 http:&#x2F;&#x2F;$ip:9090 可看到界面。  </p><p>如果系统打开了防火墙，你可能需要给以下几个端口开白名单，以centos7为例，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=9090/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=9100/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=3000/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="2-3-部署-Prometheus-Server-参考文档"><a href="#2-3-部署-Prometheus-Server-参考文档" class="headerlink" title="2.3 部署 Prometheus Server 参考文档"></a>2.3 部署 Prometheus Server 参考文档</h2><p><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">https://prometheus.io/docs/prometheus/latest/configuration/configuration/</a></p><h1 id="三、部署监控探针"><a href="#三、部署监控探针" class="headerlink" title="三、部署监控探针"></a>三、部署监控探针</h1><p>Prometheus与Zabbix不同，Prometheus主要采用主动拉取的模式，通过Exporter提供的接口读取监控数据。Exporter负责采集数据，可以把Exporter理解为探针，并通过http的方式提供接口供Server调用读取数据，读者可自行google本文未描述的各个exporter提供的返回结果内字段的含义。</p><h2 id="3-1-部署node-exporter"><a href="#3-1-部署node-exporter" class="headerlink" title="3.1 部署node_exporter"></a>3.1 部署node_exporter</h2><p>node_exporter用于监控主机的CPU，内存，磁盘，I&#x2F;O等的信息。侧重点在于主机系统本身的数据采集。</p><ol><li>下载 node exporter 并解压</li></ol><p>登录需要被监控的主机，可从 <a href="https://github.com/prometheus/node_exporter/tags">此处</a> 下载 node exporter</p><p>或者运行<code> curl -O https://github.com/prometheus/node_exporter/releases/download/v1.2.0/node_exporter-1.2.0.linux-amd64.tar.gz</code></p><p>下载完成后，运行以下命令解压二进制包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xvfz node_exporter-1.2.0.linux-amd64.tar.gz</span><br><span class="line">sudo mkdir -p /data/node_exporter/</span><br><span class="line">sudo mv node_exporter-1.2.0.linux-amd64/* /data/node_exporter/</span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建prometheus用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd prometheus</span><br><span class="line">sudo useradd -g prometheus -m -d /var/lib/prometheus -s /sbin/nologin prometheus</span><br><span class="line">sudo chown prometheus.prometheus -R /data/node_exporter/</span><br></pre></td></tr></table></figure></li><li><p>创建Systemd服务</p></li></ol><p>添加并编辑文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/node_exporter.service</span><br></pre></td></tr></table></figure><p>写入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line">Documentation=https://prometheus.io/</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=prometheus</span><br><span class="line">ExecStart=/data/node_exporter/node_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ol start="4"><li>使用systemctl 启动 node exporter<br>启动并查看服务是否正常<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start node_exporter</span><br><span class="line">sudo systemctl status node_exporter</span><br></pre></td></tr></table></figure></li></ol><p>应该返回类似以下的文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">● node_exporter.service - node_exporter</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/node_exporter.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 三 2019-06-05 09:18:56 GMT; 3s ago</span><br><span class="line"> Main PID: 11050 (node_exporter)</span><br><span class="line">   CGroup: /system.slice/node_exporter.service</span><br><span class="line">           └─11050 /usr/local/prometheus/node_exporter/node_exporter</span><br></pre></td></tr></table></figure><p>设置开机启动: <code>sudo systemctl enable node_exporter</code></p><ol start="5"><li>开启防火墙白名单<br>执行<code>curl localhost:9100</code>，如可以看到返回的网页，说明 node exporter 已经启动成功了。<br>在同网段内其他机器执行<code>curl http://$ip:9100/</code>，应同样可以看到返回的页面。</li></ol><p>如果看不到返回的页面，可以检查下是否为防火墙端口未开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=9100/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><ol start="6"><li><p>配置 Prometheus<br>登录 Prometheus 服务端，编辑以下文件<br><code>nano /data/docker/prometheus/job/host.json</code>, 内容参考如下，ip地址自行更改实际的ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;192.168.1.100:9100&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;subject&quot;: &quot;node_exporter&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;192.168.1.101:9100&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;subject&quot;: &quot;node_exporter&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>部署 node_exporter 可参考文档<br><a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a><br><a href="https://prometheus.io/docs/guides/node-exporter/">https://prometheus.io/docs/guides/node-exporter/</a><br><a href="https://www.jianshu.com/p/7bec152d1a1f">https://www.jianshu.com/p/7bec152d1a1f</a></p></li></ol><h2 id="3-2-部署mysqld-exporter"><a href="#3-2-部署mysqld-exporter" class="headerlink" title="3.2 部署mysqld-exporter"></a>3.2 部署mysqld-exporter</h2><p>mysqld-exporter 用于监控MySQL数据库的性能等数据。</p><ol><li>登录mysql数据库所在主机，并通过docker方式启动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  -p 9104:9104 \</span><br><span class="line">  --link mysql  \</span><br><span class="line">  --name mysqld-exporter \</span><br><span class="line">  --restart on-failure:5 \</span><br><span class="line">  -e DATA_SOURCE_NAME=&quot;root:pwdpwdpwdpwdpwd@(mysql:3306)/&quot; \</span><br><span class="line">  prom/mysqld-exporter:v0.13.0</span><br></pre></td></tr></table></figure></li></ol><p>启动后，访问<code>http://127.0.0.1:9104/metrics</code>，可看到监控信息，同时从Prometheus服务端访问也应要可访问的到。</p><ol start="2"><li>部署 mysqld-exporter 可参考文档<br><a href="https://github.com/prometheus/mysqld_exporter">https://github.com/prometheus/mysqld_exporter</a><br><a href="https://registry.hub.docker.com/r/prom/mysqld-exporter/">https://registry.hub.docker.com/r/prom/mysqld-exporter/</a></li></ol><h2 id="3-3-部署cadvisor"><a href="#3-3-部署cadvisor" class="headerlink" title="3.3 部署cadvisor"></a>3.3 部署cadvisor</h2><p>cadvisor用于监控容器的状态。</p><ol><li>登录docker所在主机并通过运行以下脚本启动cadvisor<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --volume=/:/rootfs:ro \</span><br><span class="line">  --volume=/var/run:/var/run:ro \</span><br><span class="line">  --volume=/sys:/sys:ro \</span><br><span class="line">  --volume=/var/lib/docker/:/var/lib/docker:ro \</span><br><span class="line">  --volume=/dev/disk/:/dev/disk:ro \</span><br><span class="line">  --publish=9101:8080 \</span><br><span class="line">  --detach=true \</span><br><span class="line">  --name=cadvisor \</span><br><span class="line">  --restart on-failure:5 \</span><br><span class="line">  --privileged \</span><br><span class="line">  --device=/dev/kmsg \</span><br><span class="line">  gcr.io/cadvisor/cadvisor:v0.38.6</span><br></pre></td></tr></table></figure></li></ol><p>你可能会找到两种 cadvisor，一种是 gcr.io&#x2F;cadvisor&#x2F;cadvisor, 另一种是 google&#x2F;cadvisor, 建议使用 gcr.io&#x2F;cadvisor&#x2F;cadvisor</p><ol start="2"><li><p>配置 Prometheus 服务端<br>登录Prometheus 服务端所在主机，编辑 <code>nano /data/docker/prometheus/job/cadvisor.json</code> 文件, 内容参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;192.168.1.100:9101&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;subject&quot;: &quot;cadvisor&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;192.168.1.101:9101&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;subject&quot;: &quot;cadvisor&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>如果docker所在主机存在防火墙，记得添加防火墙白名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=9101/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>部署 cadvisor 可参考文档<br><a href="https://github.com/google/cadvisor">https://github.com/google/cadvisor</a></p></li></ol><h2 id="3-4-部署blackbox-exporter"><a href="#3-4-部署blackbox-exporter" class="headerlink" title="3.4 部署blackbox_exporter"></a>3.4 部署blackbox_exporter</h2><p>blackbox_exporter 是以黑盒方式进行监控的工具</p><ol><li>创建配置文件<br>登录 Prometheus 服务端主机，执行以下命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/docker/blackbox/conf</span><br><span class="line">sudo chown -R myusername:myusername /data/docker/blackbox</span><br></pre></td></tr></table></figure></li></ol><p>并添加编辑该文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /data/docker/blackbox/conf/blackbox.yml</span><br></pre></td></tr></table></figure><p>yml文件范本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">modules:</span><br><span class="line">  ping:</span><br><span class="line">    prober: icmp</span><br><span class="line">    timeout: 5s</span><br><span class="line">    icmp:</span><br><span class="line">      preferred_ip_protocol: &quot;ip4&quot;</span><br><span class="line">  http_2xx:</span><br><span class="line">    prober: http</span><br><span class="line">    timeout: 5s</span><br><span class="line">    http:</span><br><span class="line">      method: GET</span><br><span class="line">      preferred_ip_protocol: &quot;ip4&quot; # defaults to &quot;ip4&quot;</span><br><span class="line">      ip_protocol_fallback: false  # no fallback to &quot;ip6&quot;</span><br><span class="line">  http_post_2xx:</span><br><span class="line">    prober: http</span><br><span class="line">    timeout: 5s</span><br><span class="line">    http:</span><br><span class="line">      method: POST</span><br><span class="line">      preferred_ip_protocol: &quot;ip4&quot;</span><br><span class="line">  http_post_2xx_json:</span><br><span class="line">    prober: http</span><br><span class="line">    timeout: 30s</span><br><span class="line">    http:</span><br><span class="line">      preferred_ip_protocol: &quot;ip4&quot;</span><br><span class="line">      method: POST</span><br><span class="line">      headers:</span><br><span class="line">        Content-Type: application/json</span><br><span class="line">      body: &#x27;&#123;&quot;key1&quot;:&quot;&quot;vlaue1,&quot;params&quot;:&#123;&quot;param2&quot;:&quot;vlaue2&quot;&#125;&#125;&#x27;</span><br><span class="line">  http_basic_auth:</span><br><span class="line">    prober: http</span><br><span class="line">    timeout: 60s</span><br><span class="line">    http:</span><br><span class="line">      method: POST</span><br><span class="line">      headers:</span><br><span class="line">        Host: &quot;login.example.com&quot;</span><br><span class="line">      basic_auth:</span><br><span class="line">        username: &quot;username&quot;</span><br><span class="line">        password: &quot;mysecret&quot;</span><br><span class="line"></span><br><span class="line">  tls_connect:</span><br><span class="line">    prober: tcp</span><br><span class="line">    timeout: 5s</span><br><span class="line">    tcp:</span><br><span class="line">      tls: true</span><br><span class="line">  tcp_connect:</span><br><span class="line">    prober: tcp</span><br><span class="line">    timeout: 5s</span><br><span class="line"></span><br><span class="line">  pop3s_banner:</span><br><span class="line">    prober: tcp</span><br><span class="line">    tcp:</span><br><span class="line">      query_response:</span><br><span class="line">      - expect: &quot;^+OK&quot;</span><br><span class="line">      tls: true</span><br><span class="line"></span><br><span class="line">  ssh_banner:</span><br><span class="line">    prober: tcp</span><br><span class="line">    tcp:</span><br><span class="line">      query_response:</span><br><span class="line">      - expect: &quot;^SSH-2.0-&quot;</span><br><span class="line">      - send: SSH-2.0-blackbox-ssh-check</span><br><span class="line"></span><br><span class="line">  irc_banner:</span><br><span class="line">    prober: tcp</span><br><span class="line">    tcp:</span><br><span class="line">      query_response:</span><br><span class="line">      - send: &quot;NICK prober&quot;</span><br><span class="line">      - send: &quot;USER prober prober prober :prober&quot;</span><br><span class="line">      - expect: &quot;PING :([^ ]+)&quot;</span><br><span class="line">        send: &quot;PONG $&#123;1&#125;&quot;</span><br><span class="line">      - expect: &quot;^:[^ ]+ 001&quot;</span><br><span class="line"></span><br><span class="line">  dns_udp:</span><br><span class="line">    prober: dns</span><br><span class="line">    timeout: 10s</span><br><span class="line">    dns:</span><br><span class="line">      transport_protocol: udp</span><br><span class="line">      preferred_ip_protocol: ip4</span><br><span class="line">      query_name: &quot;www.example.cn&quot;</span><br><span class="line">      query_type: &quot;A&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 Prometheus<br>继续在 Prometheus 服务端主机，执行以下命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/docker/prometheus/job/blackbox/</span><br><span class="line"></span><br><span class="line">sudo mkdir -pv /data/docker/prometheus/job/blackbox/&#123;dns,http_2xx,ping,ssh_banner,tcp&#125;</span><br><span class="line">sudo chown -R myusername:myusername /data/docker/prometheus/job/blackbox/</span><br></pre></td></tr></table></figure></li></ol><p>以下依次在<code>/data/docker/prometheus/job/blackbox/</code>下的对应的文件夹中，创建json文件，并参考样本写入配置</p><p>在dns文件夹下，创建 dns.json，样本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;192.168.1.1&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_dns&quot;,</span><br><span class="line">      &quot;app&quot;: &quot;my_dns&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在http_2xx文件夹下，创建 search-site.json，样本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;https://www.google.cn/?HealthCheck&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;app&quot;: &quot;google&quot;,</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_http_2xx&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server-01&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;https://cn.bing.com/?HealthCheck&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;app&quot;: &quot;bing&quot;,</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_http_2xx&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server-02&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在ping文件夹下，创建 search-site.json，样本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;www.google.cn&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;app&quot;: &quot;google&quot;,</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_ping&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server-01&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;cn.bing.com&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;app&quot;: &quot;bing&quot;,</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_ping&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server-02&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在ssh_banner文件夹下，创建 ssh-banner.json，样本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;192.168.1.100:22&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_ssh_banner&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server-01&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;192.168.1.101:22&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_ssh_banner&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;server-02&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在tcp文件夹下，创建 tcp.json，样本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;targets&quot;: [ &quot;$ip:3306&quot;],</span><br><span class="line">    &quot;labels&quot;: &#123;</span><br><span class="line">      &quot;app&quot;: &quot;mysql.example.cn&quot;,</span><br><span class="line">      &quot;subject&quot;: &quot;blackbox_tcp&quot;,</span><br><span class="line">      &quot;hostname&quot;: &quot;mysql&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="3"><li>运行blackbox_exporter</li></ol><p>在 Prometheus服务端所在的主机，运行以下命令，使用容器启动blackbox_exporter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --restart on-failure:5 \</span><br><span class="line">  -p 9115:9115 \</span><br><span class="line">  -v /data/docker/blackbox/conf/blackbox.yml:/config/blackbox.yml:ro \</span><br><span class="line">  --name blackbox_exporter \</span><br><span class="line">  prom/blackbox-exporter:v0.19.0 \</span><br><span class="line">  --config.file=/config/blackbox.yml</span><br></pre></td></tr></table></figure><p>启动成功后，访问<code>http://$ip:9090/targets</code>，可看到至今为止，我们配置的所有探针所反馈回来的数据，其中，State应为UP状态。</p><ol start="4"><li>部署 blackbox_exporter 可参考文档<br><a href="https://github.com/prometheus/blackbox_exporter">https://github.com/prometheus/blackbox_exporter</a><br><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/exporter/commonly-eporter-usage/install_blackbox_exporter">https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/exporter/commonly-eporter-usage/install_blackbox_exporter</a></li></ol><h1 id="四、部署Grafana"><a href="#四、部署Grafana" class="headerlink" title="四、部署Grafana"></a>四、部署Grafana</h1><p>接下来，部署可视化工具Grafana，Grafana可快速集成Prometheus，并通过设定甚至是使用现成的模板，快速将采集结果转变为图形化的页面。</p><h2 id="4-1-启动"><a href="#4-1-启动" class="headerlink" title="4.1 启动"></a>4.1 启动</h2><p>运行以下命令，做启动前的准备工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/docker/grafana</span><br><span class="line">sudo chown 472:472 /data/docker/grafana -R</span><br></pre></td></tr></table></figure><p>通过docker运行grafana</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  --name=grafana \</span><br><span class="line">  -v /data/docker/grafana:/var/lib/grafana \</span><br><span class="line">  -v /etc/localtime:/etc/localtime:ro \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name grafana \</span><br><span class="line">  grafana/grafana:8.0.6</span><br></pre></td></tr></table></figure><p>启动成功后，可通过<code>http://$ip:3000</code>访问页面，默认账号密码: admin &#x2F; admin 。</p><h2 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h2><ol><li><p>配置数据源<br>点击“Configuration -&gt; Data sources”，进入 <code>http://$ip:3000/datasources</code>，增加Prometheus数据源，并做好配置。</p></li><li><p>配置Dashboards</p></li></ol><p>点击“Dashboards -&gt; Manage -&gt; import”，进入<code>http://$ip:3000/dashboard/import</code>，导入 Grafana Dashboards 模板，在<code>Import via grafana.com</code>处，填入你想要导入的模板id，常用的模板id如下：</p><ul><li>node exporter ID: 8919</li><li>Cadvisor ID: 14282</li><li>mysqld-exporter ID: 7362</li></ul><p>你也可以在<code>https://grafana.com/grafana/dashboards</code>，自行搜索 Dashboards 模板。也可以自行创建dashboard面板。</p><h2 id="4-3-部署-Grafana-可参考文档"><a href="#4-3-部署-Grafana-可参考文档" class="headerlink" title="4.3 部署 Grafana 可参考文档"></a>4.3 部署 Grafana 可参考文档</h2><p><a href="https://grafana.com/docs/grafana/latest/installation/docker/">https://grafana.com/docs/grafana/latest/installation/docker/</a></p><h1 id="五、部署AlertManager"><a href="#五、部署AlertManager" class="headerlink" title="五、部署AlertManager"></a>五、部署AlertManager</h1><p>截至到现在，我们已经部署好Prometheus Server，Exporter，Grafana可视化组件，我们还需要配置告警组件，当故障出现时，监控系统可通过多种方式告知接收人，以便接收人及时知晓并处理。但Prometheus本身并不自带告警工具，Prometheus可以通过预配置的规则，将信息发送到AlertManager，由AlertManager统一处理告警信息，并通过邮箱，短信，微信，钉钉等方式告知告警接收人。和Grafana一样，AlertManager同样不仅仅支持Prometheus，也支持集成处理其他程序的信息。</p><h2 id="5-1-准备工作"><a href="#5-1-准备工作" class="headerlink" title="5.1 准备工作"></a>5.1 准备工作</h2><p>运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -pv /data/docker/alertmanager</span><br><span class="line">sudo chown -R myusername:myusername /data/docker/alertmanager/</span><br><span class="line">cd /data/docker/alertmanager</span><br></pre></td></tr></table></figure><p>在<code>/data/docker/alertmanager</code>文件夹中，创建alertmanager.yml 和 email.tmpl 文件，</p><p>alertmanager.yml的样例如下，注意要设置smtp相关配置项与webhook的ddurl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">  # 邮件SMTP配置</span><br><span class="line">  smtp_smarthost: &#x27;smtp.gmail.com:465&#x27;</span><br><span class="line">  smtp_from: &#x27;example@gmail.com&#x27;</span><br><span class="line">  smtp_auth_username: &#x27;example@gmail.com&#x27;</span><br><span class="line">  smtp_auth_password: &#x27;xxxxx&#x27;</span><br><span class="line">  smtp_require_tls: false</span><br><span class="line"># 自定义通知模板</span><br><span class="line">templates:</span><br><span class="line">  - &#x27;/etc/alertmanager/email.tmpl&#x27;</span><br><span class="line"># route用来设置报警的分发策略</span><br><span class="line">route:</span><br><span class="line">  # 采用哪个标签来作为分组依据</span><br><span class="line">  group_by: [&#x27;alertname&#x27;]</span><br><span class="line">  # 组告警等待时间。也就是告警产生后等待10s，如果有同组告警一起发出</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  # 两组告警的间隔时间</span><br><span class="line">  group_interval: 10s</span><br><span class="line">  # 重复告警的间隔时间，减少相同邮件的发送频率</span><br><span class="line">  repeat_interval: 1h</span><br><span class="line">  # 设置默认接收人</span><br><span class="line">  receiver: &#x27;myreceiver&#x27;</span><br><span class="line">  routes:   # 可以指定哪些组接手哪些消息</span><br><span class="line">  - receiver: &#x27;myreceiver&#x27;</span><br><span class="line">    continue: true</span><br><span class="line">    group_wait: 10s</span><br><span class="line">receivers:</span><br><span class="line">- name: &#x27;myreceiver&#x27;</span><br><span class="line">#send_resolved: true</span><br><span class="line">  email_configs:</span><br><span class="line">  # - to: &#x27;example@gmail.com, example2@gmail.com&#x27;</span><br><span class="line">  - to: &#x27;example@gmail.com&#x27;</span><br><span class="line">    html: &#x27;&#123;&#123; template &quot;email.to.html&quot; . &#125;&#125;&#x27;</span><br><span class="line">    headers: &#123; Subject: &quot;Prometheus [Warning] 报警邮件&quot; &#125;</span><br><span class="line">  # 钉钉配置</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: &#x27;http://$ip:18080/prometheusalert?type=dd&amp;tpl=prometheus-dd&amp;ddurl=https://oapi.dingtalk.com/robot/send?access_token=xxxxxx&#x27;</span><br></pre></td></tr></table></figure><p>email.tmpl的样例如下，注意样例中有一个”2006-01-02 15:04:05”，这个时间不能改，否则报警显示时间可能会不正确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;email.to.html&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len .Alerts.Firing) 0 -&#125;&#125;</span><br><span class="line">&#123;&#123; range .Alerts &#125;&#125;</span><br><span class="line">=========start==========&lt;br&gt;</span><br><span class="line">告警程序: prometheus_alert &lt;br&gt;</span><br><span class="line">告警级别: &#123;&#123; .Labels.severity &#125;&#125; &lt;br&gt;</span><br><span class="line">告警类型: &#123;&#123; .Labels.alertname &#125;&#125; &lt;br&gt;</span><br><span class="line">告警应用: &#123;&#123; .Labels.app &#125;&#125; &lt;br&gt;</span><br><span class="line">告警主机: &#123;&#123; .Labels.instance &#125;&#125; &lt;br&gt;</span><br><span class="line">告警主题: &#123;&#123; .Annotations.summary &#125;&#125;  &lt;br&gt;</span><br><span class="line">告警详情: &#123;&#123; .Annotations.description &#125;&#125; &lt;br&gt;</span><br><span class="line">触发时间: &#123;&#123; (.StartsAt.Add 28800e9).Format &quot;2006-01-02 15:04:05&quot; &#125;&#125; &lt;br&gt;</span><br><span class="line">=========end==========&lt;br&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end -&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- if gt (len .Alerts.Resolved) 0 -&#125;&#125;</span><br><span class="line">&#123;&#123; range .Alerts &#125;&#125;</span><br><span class="line">=========start==========&lt;br&gt;</span><br><span class="line">告警程序: prometheus_alert &lt;br&gt;</span><br><span class="line">告警级别: &#123;&#123; .Labels.severity &#125;&#125; &lt;br&gt;</span><br><span class="line">告警类型: &#123;&#123; .Labels.alertname &#125;&#125; &lt;br&gt;</span><br><span class="line">告警应用: &#123;&#123; .Labels.app &#125;&#125; &lt;br&gt;</span><br><span class="line">告警主机: &#123;&#123; .Labels.instance &#125;&#125; &lt;br&gt;</span><br><span class="line">告警主题: &#123;&#123; .Annotations.summary &#125;&#125; &lt;br&gt;</span><br><span class="line">告警详情: &#123;&#123; .Annotations.description &#125;&#125; &lt;br&gt;</span><br><span class="line">触发时间: &#123;&#123; (.StartsAt.Add 28800e9).Format &quot;2006-01-02 15:04:05&quot; &#125;&#125; &lt;br&gt;</span><br><span class="line">恢复时间: &#123;&#123; (.EndsAt.Add 28800e9).Format &quot;2006-01-02 15:04:05&quot; &#125;&#125; &lt;br&gt;</span><br><span class="line">=========end==========&lt;br&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end -&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>这两个配置文件，可参考 <a href="https://prometheus.io/docs/alerting/latest/configuration/">https://prometheus.io/docs/alerting/latest/configuration/</a> 进行修改。</p><h2 id="5-2-启动AlertManager"><a href="#5-2-启动AlertManager" class="headerlink" title="5.2 启动AlertManager"></a>5.2 启动AlertManager</h2><p>运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9093:9093 \</span><br><span class="line">  -v /data/docker/alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml:ro \</span><br><span class="line">  -v /data/docker/alertmanager/email.tmpl/:/etc/alertmanager/email.tmpl:ro \</span><br><span class="line">  --name alertmanager \</span><br><span class="line">  --restart=always \</span><br><span class="line">  prom/alertmanager:v0.22.2</span><br></pre></td></tr></table></figure><h2 id="5-3-访问"><a href="#5-3-访问" class="headerlink" title="5.3 访问"></a>5.3 访问</h2><p>启动成功后，可通过<code>http://$ip:9093</code>访问alertmanager组件</p><h1 id="六、部署PrometheusAlert"><a href="#六、部署PrometheusAlert" class="headerlink" title="六、部署PrometheusAlert"></a>六、部署PrometheusAlert</h1><p>上节已经提到，Prometheus告警需由两部分组成，上节我们已经部署好AlertManager用于信息处理与通知，本节我们需要定义好Prometheus的配置规则，如此Prometheus便可以产生告警信息并发送到AlertManager。</p><h2 id="6-1-准备工作"><a href="#6-1-准备工作" class="headerlink" title="6.1 准备工作"></a>6.1 准备工作</h2><p>运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/docker/prometheus-alert/conf</span><br><span class="line">sudo chown -R fenixadar:fenixadar /data/docker/prometheus-alert/</span><br><span class="line">nano /data/docker/prometheus-alert/conf/app.conf</span><br></pre></td></tr></table></figure><p>从 <a href="https://raw.githubusercontent.com/feiyu563/PrometheusAlert/master/conf/app-example.conf">https://raw.githubusercontent.com/feiyu563/PrometheusAlert/master/conf/app-example.conf</a> 下载文件并移动到 &#x2F;data&#x2F;docker&#x2F;prometheus-alert&#x2F;conf&#x2F;app.conf</p><h2 id="6-2-启动"><a href="#6-2-启动" class="headerlink" title="6.2 启动"></a>6.2 启动</h2><p>运行以下命令开启prometheus-alert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --publish=18080:8080 \</span><br><span class="line">  -v /data/docker/prometheus-alert/conf/:/app/conf:ro \</span><br><span class="line">  -v /data/docker/prometheus-alert/db/:/app/db \</span><br><span class="line">  -v /data/docker/prometheus-alert/log/:/app/logs \</span><br><span class="line">  --name prometheusalert-center \</span><br><span class="line">  feiyu563/prometheus-alert:v-4.5.0</span><br></pre></td></tr></table></figure><p>开启成功后，通过<code>http://$ip:18080</code>，访问prometheus-alert界面。用户密码已在 app.conf 中设置。</p><p>如果系统开启了防火墙，记得开放白名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=18080/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="6-3-配置"><a href="#6-3-配置" class="headerlink" title="6.3 配置"></a>6.3 配置</h2><ol><li>配置告警模板</li></ol><p>点击AlertTemplate，进入<code>http://$ip:18080/template</code>，此处有各类可对接的第三方系统的模板。<br>以钉钉的告警模板为例，将模版内容改为如下，主要是修正时间显示慢8小时的问题，以及增加一些信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; $var := .externalURL&#125;&#125;&#123;&#123; range $k,$v:=.alerts &#125;&#125;</span><br><span class="line">&#123;&#123;if eq $v.status &quot;resolved&quot;&#125;&#125;</span><br><span class="line">## [Prometheus恢复信息](&#123;&#123;$v.generatorURL&#125;&#125;)</span><br><span class="line">#### [&#123;&#123;$v.labels.alertname&#125;&#125;](&#123;&#123;$var&#125;&#125;)</span><br><span class="line">###### 告警级别：&#123;&#123;$v.labels.level&#125;&#125;</span><br><span class="line">###### 开始时间：&#123;&#123;GetCSTtime $v.startsAt&#125;&#125;</span><br><span class="line">###### 结束时间：&#123;&#123;GetCSTtime $v.endsAt&#125;&#125;</span><br><span class="line">###### 故障主机名：&#123;&#123;$v.labels.hostname&#125;&#125;</span><br><span class="line">###### 故障主机IP：&#123;&#123;$v.labels.instance&#125;&#125;</span><br><span class="line">###### 故障应用：&#123;&#123;$v.labels.app&#125;&#125;</span><br><span class="line">###### 故障主机对象：&#123;&#123;$v.labels.subject&#125;&#125;</span><br><span class="line">##### &#123;&#123;$v.annotations.description&#125;&#125;</span><br><span class="line">![Prometheus](https://raw.githubusercontent.com/feiyu563/PrometheusAlert/master/doc/alert-center.png)</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">## [Prometheus告警信息](&#123;&#123;$v.generatorURL&#125;&#125;)</span><br><span class="line">#### [&#123;&#123;$v.labels.alertname&#125;&#125;](&#123;&#123;$var&#125;&#125;)</span><br><span class="line">###### 告警级别：&#123;&#123;$v.labels.level&#125;&#125;</span><br><span class="line">###### 开始时间：&#123;&#123;GetCSTtime $v.startsAt&#125;&#125;</span><br><span class="line">###### 故障主机名：&#123;&#123;$v.labels.hostname&#125;&#125;</span><br><span class="line">###### 故障主机IP：&#123;&#123;$v.labels.instance&#125;&#125;</span><br><span class="line">###### 故障应用：&#123;&#123;$v.labels.app&#125;&#125;</span><br><span class="line">###### 故障主机对象：&#123;&#123;$v.labels.subject&#125;&#125;</span><br><span class="line">##### &#123;&#123;$v.annotations.description&#125;&#125;</span><br><span class="line">![Prometheus](https://raw.githubusercontent.com/feiyu563/PrometheusAlert/master/doc/alert-center.png)</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置钉钉机器人<br>在钉钉中，新建一个钉钉群，点击“群设置 -&gt; 智能群助手 -&gt; 添加机器人 -&gt; 自定义 -&gt; 安全设置”，把发送信息的服务器IP地址加进去，而后就会有 Webhook 地址。可参考 <a href="https://blog.csdn.net/knight_zhou/article/details/105583741">https://blog.csdn.net/knight_zhou/article/details/105583741</a></li></ol><h2 id="6-4-部署-PrometheusAlert-可参考文档"><a href="#6-4-部署-PrometheusAlert-可参考文档" class="headerlink" title="6.4 部署 PrometheusAlert 可参考文档"></a>6.4 部署 PrometheusAlert 可参考文档</h2><p><a href="https://github.com/feiyu563/PrometheusAlert/blob/master/doc/readme/install.md">https://github.com/feiyu563/PrometheusAlert/blob/master/doc/readme/install.md</a></p><h1 id="七、配置告警规则"><a href="#七、配置告警规则" class="headerlink" title="七、配置告警规则"></a>七、配置告警规则</h1><p>我们还需要在Prometheus Server中配置告警规则，告警规则文件引用配置在prometheus.yml文件的rule_files一节中。规则文件格式是yml，依照2.1小节的配置，在<code>/data/docker/prometheus/alert_rules/</code>文件夹创建yml文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: Node_exporter Down</span><br><span class="line">  rules:</span><br><span class="line">  - alert: 实例丢失</span><br><span class="line">    expr: up&#123;job=&quot;node_exporter&quot;&#125; == 0</span><br><span class="line">    for: 1m</span><br><span class="line">    labels:</span><br><span class="line">      level: Warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;&#123;&#123; $labels.job &#125;&#125;&quot;</span><br><span class="line">      address: &quot;&#123;&#123; $labels.instance &#125;&#125;&quot;</span><br><span class="line">      description: &quot;已经有1分钟连接不上实例了.&quot;</span><br><span class="line">  - alert: CPU使用率过高(&gt; 80)</span><br><span class="line">    expr: 100 - (avg by(instance) (rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[2m])) * 100) &gt; 80</span><br><span class="line">    for: 1m</span><br><span class="line">    labels:</span><br><span class="line">      level: Warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;&#123;&#123; $labels.instance &#125;&#125; CPU使用率过高&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: CPU使用率超过80%，当前使用率&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 内存使用率过高(&gt; 80)</span><br><span class="line">    expr: (node_memory_MemTotal_bytes - (node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes )) / node_memory_MemTotal_bytes * 100 &gt; 80</span><br><span class="line">    for: 1m  #告警持续时间，超过这个时间才会发送给alertmanager</span><br><span class="line">    labels:</span><br><span class="line">      level: Warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;&#123;&#123; $labels.instance &#125;&#125; 内存使用率过高&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;：内存使用率超过80%. 当前使用率&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 内存压力过大 (&gt; 1000)</span><br><span class="line">    expr: rate(node_vmstat_pgmajfault[1m]) &gt; 1000</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 内存压力过大&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;：内存压力很大. 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 主机网络接口接收了太多的数据 (&gt; 2MB/s)</span><br><span class="line">    expr: sum by (instance) (rate(node_network_receive_bytes_total[2m])) / 1024 / 1024 &gt; 2</span><br><span class="line">    for: 5m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)主机入向流量异常&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;：持续3分钟网口接收太多数据(&gt; 2MB/s). 当前使用入向流量&#123;&#123; $value &#125;&#125;MB每秒.&quot;</span><br><span class="line">  - alert: 主机网络接口发送了太多的数据 (&gt; 2MB/s)</span><br><span class="line">    expr: sum by (instance) (rate(node_network_transmit_bytes_total[2m])) / 1024 / 1024 &gt; 100</span><br><span class="line">    for: 3m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机出向流量异常&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;：持续3分钟网口发送太多数据(&gt; 2MB/s). 当前使用入向流量&#123;&#123; $value &#125;&#125;MB每秒.&quot;</span><br><span class="line">  - alert: 磁盘每秒读数据（&gt; 50 MB/s）</span><br><span class="line">    expr: sum by (instance) (rate(node_disk_read_bytes_total[2m])) / 1024 / 1024 &gt; 50</span><br><span class="line">    for: 3m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机IO读取异常&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;：主机的IO读取有些问题. 当前值每秒&#123;&#123; $value &#125;&#125;MB&quot;</span><br><span class="line">  - alert: 磁盘每秒写数据（&gt; 50 MB/s）</span><br><span class="line">    expr: sum by (instance) (rate(node_disk_written_bytes_total[2m])) / 1024 / 1024 &gt; 50</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">     summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机IO写入异常&quot;</span><br><span class="line">     description: &quot;&#123;&#123; $labels.instance &#125;&#125;：主机的IO写入有些问题. 当前值每秒&#123;&#123; $value &#125;&#125;MB&quot;</span><br><span class="line">  # Please add ignored mountpoints in node_exporter parameters like</span><br><span class="line">  # &quot;--collector.filesystem.ignored-mount-points=^/(sys|proc|dev|run)($|/)&quot;.</span><br><span class="line">  # Same rule using &quot;node_filesystem_free_bytes&quot; will fire when disk fills for non-root users.</span><br><span class="line">  - alert: 磁盘可用空间（&lt;10% left）</span><br><span class="line">    expr: (node_filesystem_avail_bytes * 100) / node_filesystem_size_bytes &lt; 10 and ON (instance, device, mountpoint) node_filesystem_readonly == 0</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机磁盘告急&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 主机大约还剩10%的磁盘存储. 当前可用剩余&#123;&#123; $value &#125;&#125;%&quot;</span><br><span class="line">  - alert: 磁盘读取延迟大（&gt;100ms）</span><br><span class="line">    expr: rate(node_disk_read_time_seconds_total[1m]) / rate(node_disk_reads_completed_total[1m]) &gt; 0.1 and rate(node_disk_reads_completed_total[1m]) &gt; 0</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机IO读取延迟大&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 主机的IO读取延迟有些大 &gt;100ms . 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 磁盘写入延迟大（&gt;100ms）</span><br><span class="line">    expr: rate(node_disk_write_time_seconds_total[1m]) / rate(node_disk_writes_completed_total[1m]) &gt; 0.1 and rate(node_disk_writes_completed_total[1m]) &gt; 0</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机IO写入延迟大&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 主机的IO写入延迟有些大 &gt;100ms . 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">  # 1000 context switches is an arbitrary number.</span><br><span class="line">  # Alert threshold depends on nature of application.</span><br><span class="line">  # Please read: https://github.com/samber/awesome-prometheus-alerts/issues/58</span><br><span class="line">  #- alert: 上下文切换的节点越来越多(&gt;1500/s)</span><br><span class="line">  #  expr: (rate(node_context_switches_total[5m])) / (count without(cpu, mode) (node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;)) &gt; 1500</span><br><span class="line">  #  for: 3m</span><br><span class="line">  #  labels:</span><br><span class="line">  #    level: warning</span><br><span class="line">  #  annotations:</span><br><span class="line">  #    summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机上下文节点堆积&quot;</span><br><span class="line">  #    description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 主机上下文节点堆积严重 &gt;1500/s . 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 主机 swap 交换分区使用情况 (&gt; 80%)</span><br><span class="line">    expr: (1 - (node_memory_SwapFree_bytes / node_memory_SwapTotal_bytes)) * 100 &gt; 80</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机交换空间警告&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 主机交换内存到达 &gt; 80% . 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 主机 systemctl 管理的服务 down</span><br><span class="line">    expr: node_systemd_unit_state&#123;state=&quot;failed&quot;&#125; == 1</span><br><span class="line">    for: 0m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 有systemctl服务被DOWN&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 的&#123;&#123; $value &#125;&#125;服务被systemctl方式DOWN了&quot;</span><br><span class="line">  - alert: 物理机温度过高( &gt;75°)</span><br><span class="line">    expr: node_hwmon_temp_celsius &gt; 75</span><br><span class="line">    for: 5m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机物理机温度告警&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 主机物理机温度异常( &gt;75°)，当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 触发物理节点温度报警</span><br><span class="line">    expr: node_hwmon_temp_crit_alarm_celsius == 1</span><br><span class="line">    for: 0m</span><br><span class="line">    labels:</span><br><span class="line">      level: critical</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机主板温度告警&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 主板的温度过高，当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 主机五分钟内接收到错误包</span><br><span class="line">    expr: rate(node_network_receive_errs_total[2m]) / rate(node_network_receive_packets_total[2m]) &gt; 0.01</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机网络接收到错误包&quot;</span><br><span class="line">      description: &quot;主机  &#123;&#123; $labels.instance &#125;&#125; interface &#123;&#123; $labels.device &#125;&#125; 在过去五分钟内遇到了 &#123;&#123; printf \&quot;%.0f\&quot; $value &#125;&#125; 接收错误&quot;</span><br><span class="line">  - alert: 主机五分钟内发送了错误包</span><br><span class="line">    expr: rate(node_network_transmit_errs_total[2m]) / rate(node_network_transmit_packets_total[2m]) &gt; 0.01</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 主机网络发送了错误包&quot;</span><br><span class="line">      description: &quot;主机  &#123;&#123; $labels.instance &#125;&#125; interface &#123;&#123; $labels.device &#125;&#125; 在过去五分钟内遇到了 &#123;&#123; printf \&quot;%.0f\&quot; $value &#125;&#125; 接收错误&quot;</span><br><span class="line">  - alert: TCP连接时间过长</span><br><span class="line">    expr: probe_duration_seconds&#123;job=&quot;blackbox_tcp&quot;&#125; &gt; 5</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) TCP连接时间大于5秒&quot;</span><br><span class="line">      description: &quot;TCP连接时间大于5秒, 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 主机TCP连接数</span><br><span class="line">    expr: node_netstat_Tcp_CurrEstab &gt; 800</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) TCP连接数过多&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 检测过多TCP连接 &gt; 800, 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 待关闭的TCP连接数 &gt; 4000</span><br><span class="line">    expr: node_sockstat_TCP_tw &gt; 4000</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 等待关闭的TCP连接数 &gt; 4000&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 检测到过多待关闭的TCP连接数, 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 检测到时钟偏差</span><br><span class="line">    expr: (node_timex_offset_seconds &gt; 0.05 and deriv(node_timex_offset_seconds[5m]) &gt;= 0) or (node_timex_offset_seconds &lt; -0.05 and deriv(node_timex_offset_seconds[5m]) &lt;= 0)</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 检测到时钟偏差&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 检测到时钟偏差。时钟不同步, 当前值&#123;&#123; $value &#125;&#125;&quot;</span><br><span class="line">  - alert: 容器停止运行检测</span><br><span class="line">    expr: time() - container_last_seen &gt; 300</span><br><span class="line">    for: 0m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;) 容器可能已经停止运行了&quot;</span><br><span class="line">      description: &quot;容器：&#123;&#123; $labels.name &#125;&#125; - &#123;&#123; $value &#125;&#125;可能已经停止运行了&quot;</span><br><span class="line">  # cAdvisor can sometimes consume a lot of CPU, so this alert will fire constantly.</span><br><span class="line">  # If you want to exclude it from this alert, exclude the serie having an empty name: container_cpu_usage_seconds_total&#123;name!=&quot;&quot;&#125;</span><br><span class="line">  - alert: 容器CPU使用情况</span><br><span class="line">    expr: (sum(rate(container_cpu_usage_seconds_total[3m])) BY (instance, name) * 100) &gt; 300</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)容器CPU过高&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 容器CPU 使用率 &gt;300% , 当前值&#123;&#123; $value &#125;&#125;%&quot;</span><br><span class="line">  # See https://medium.com/faun/how-much-is-too-much-the-linux-oomkiller-and-used-memory-d32186f29c9d</span><br><span class="line">  #- alert: 容器内存使用情况</span><br><span class="line">  #  expr: (sum(container_memory_working_set_bytes) BY (instance, name) / sum(container_spec_memory_limit_bytes &gt; 0) BY (instance, name) * 100) &gt; 85</span><br><span class="line">  #  for: 2m</span><br><span class="line">  #  labels:</span><br><span class="line">  #    level: warning</span><br><span class="line">  #  annotations:</span><br><span class="line">  #    summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)容器内存过高&quot;</span><br><span class="line">  #    description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 容器&#123;&#123; $labels.name &#125;&#125;内存 使用率 &gt;85% , 当前值&#123;&#123; $value &#125;&#125;%&quot;</span><br><span class="line">  - alert: 容器卷使用情况</span><br><span class="line">    expr: (1 - (sum(container_fs_inodes_free) BY (instance) / sum(container_fs_inodes_total) BY (instance))) * 100 &gt; 80</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)容器Volume过高&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 容器&#123;&#123; $labels.name &#125;&#125;,Volume 使用率 &gt;80% , 当前值&#123;&#123; $value &#125;&#125;%&quot;</span><br><span class="line">  - alert: 容器卷IO使用率</span><br><span class="line">    expr: (sum(container_fs_io_current) BY (instance, name) * 100) &gt; 80</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)容器Volume IO过高&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 容器&#123;&#123; $labels.name &#125;&#125;，Volume IO使用率 &gt;80% , 当前值&#123;&#123; $value &#125;&#125;%&quot;</span><br><span class="line">  - alert: 容器高字节流情况</span><br><span class="line">    expr: rate(container_cpu_cfs_throttled_seconds_total[3m]) &gt; 1</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)容器字节流过高&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125;: 容器&#123;&#123; $labels.name &#125;&#125;字节流过高&quot;</span><br><span class="line">  - alert: Blackbox探针状态</span><br><span class="line">    expr: probe_success == 0</span><br><span class="line">    for: 5m</span><br><span class="line">    labels:</span><br><span class="line">      level: critical</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)黑盒检测发现问题&quot;</span><br><span class="line">      description: &quot;任务组&#123;&#123; $labels.job &#125;&#125;采集到问题&quot;</span><br><span class="line">  - alert: Blackbox慢采集</span><br><span class="line">    expr: avg_over_time(probe_duration_seconds[1m]) &gt; 15</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)黑盒采集过慢&quot;</span><br><span class="line">      description: &quot;Blackbox用了&#123;&#123; $value &#125;&#125;秒多的时间才完成, &#123;&#123; $labels &#125;&#125;&quot;</span><br><span class="line">  - alert: Blackbox Ping时间过长</span><br><span class="line">    expr: probe_duration_seconds&#123;job=&quot;blackbox_ping&quot;&#125; &gt; 5</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)Blackbox Ping时间过长&quot;</span><br><span class="line">      description: &quot;Ping 时间大于5秒, &#123;&#123; $value &#125;&#125;,&#123;&#123; $labels &#125;&#125;&quot;</span><br><span class="line">  - alert: Blackbox探测Http失败</span><br><span class="line">    expr: probe_http_status_code &lt;= 199 OR probe_http_status_code &gt;= 400</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: critical</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;(instance &#123;&#123; $labels.instance &#125;&#125;)Blackbox探测Http失败&quot;</span><br><span class="line">      description: &quot;HTTP状态代码不是200-399, &#123;&#123; $value &#125;&#125;,&#123;&#123; $labels &#125;&#125;&quot;</span><br><span class="line">  - alert: SSL 证书 30 天后到期</span><br><span class="line">    expr: probe_ssl_earliest_cert_expiry - time() &lt; 86400 * 30</span><br><span class="line">    for: 60m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: Blackbox SSL证书将很快过期(instance &#123;&#123; $labels.instance &#125;&#125;)</span><br><span class="line">      description: &quot;SSL 证书将在30天后过期，&#123;&#123; $value &#125;&#125;，&#123;&#123; $labels &#125;&#125;&quot;</span><br><span class="line">  - alert: SSL 证书 3 天后到期</span><br><span class="line">    expr: probe_ssl_earliest_cert_expiry - time() &lt; 86400 * 3</span><br><span class="line">    for: 60m</span><br><span class="line">    labels:</span><br><span class="line">      level: critical</span><br><span class="line">    annotations:</span><br><span class="line">      summary: Blackbox SSL证书将很快过期(instance &#123;&#123; $labels.instance &#125;&#125;)</span><br><span class="line">      description: &quot;SSL 证书将在3天后过期，&#123;&#123; $value &#125;&#125;，&#123;&#123; $labels &#125;&#125;&quot;</span><br><span class="line">  - alert: SSL 证书已经到期</span><br><span class="line">    expr: probe_ssl_earliest_cert_expiry - time() &lt;= 0</span><br><span class="line">    for: 60m</span><br><span class="line">    labels:</span><br><span class="line">      level: critical</span><br><span class="line">    annotations:</span><br><span class="line">      summary: Blackbox SSL证书已经过期(instance &#123;&#123; $labels.instance &#125;&#125;)</span><br><span class="line">      description: &quot;SSL 证书过期了 ，&#123;&#123; $value &#125;&#125;，&#123;&#123; $labels &#125;&#125;&quot;</span><br><span class="line">  - alert: Blackbox采集HTTP过慢</span><br><span class="line">    expr: avg_over_time(probe_http_duration_seconds[1m]) &gt; 3</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;Blackbox 探测慢速Http (instance &#123;&#123; $labels.instance &#125;&#125;)&quot;</span><br><span class="line">      description: &quot;HTTP请求耗时超过3s, 当前值&#123;&#123; $value &#125;&#125;,任务对象&#123;&#123; $labels.instance &#125;&#125;&quot;</span><br><span class="line">  - alert: Blackbox采集ICMP过慢</span><br><span class="line">    expr: avg_over_time(probe_icmp_duration_seconds[1m]) &gt; 3</span><br><span class="line">    for: 2m</span><br><span class="line">    labels:</span><br><span class="line">      level: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;Blackbox 探测慢速icmp (instance &#123;&#123; $labels.instance &#125;&#125;)&quot;</span><br><span class="line">      description: &quot;ICMP请求耗时超过3s, 当前值&#123;&#123; $value &#125;&#125;,任务对象&#123;&#123; $labels.instance &#125;&#125;&quot;</span><br><span class="line">  - alert: DNS服务器宕机</span><br><span class="line">    expr: probe_dns_answer_rrs == 0</span><br><span class="line">    for: 1m</span><br><span class="line">    labels:</span><br><span class="line">      level: Warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;DNS服务器宕机&quot;</span><br><span class="line">      description: &quot;DNS服务器已经有1分钟未响应了，可能已宕机.&quot;</span><br></pre></td></tr></table></figure><p>配置好规则文件后，重启Prometheus Server，可在<code>http://$ip:9090/rules</code>页面查看规则。可以自行搜索下警报状态相关的知识点。  </p><p>可参考文档：<a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言与目录&quot;&gt;&lt;a href=&quot;#一、前言与目录&quot; class=&quot;headerlink&quot; title=&quot;一、前言与目录&quot;&gt;&lt;/a&gt;一、前言与目录&lt;/h1&gt;&lt;p&gt;监控是当前云原生时代下可观测性中关键性的一环，较之前相比，云原生时代已经发生了诸多变化，诸如微服务，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>goframe与gin对比(四) 数据返回、Cookie、session、HTTPClient</title>
    <link href="https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E5%9B%9B)%20%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E3%80%81Cookie%E3%80%81session%E3%80%81HTTPClient/"/>
    <id>https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E5%9B%9B)%20%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E3%80%81Cookie%E3%80%81session%E3%80%81HTTPClient/</id>
    <published>2021-10-28T10:51:05.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据返回"><a href="#数据返回" class="headerlink" title="数据返回"></a>数据返回</h1><h2 id="JSON-x2F-XML支持"><a href="#JSON-x2F-XML支持" class="headerlink" title="JSON&#x2F;XML支持"></a>JSON&#x2F;XML支持</h2><p>两者均支持序列化对象，输出json和xml格式数据</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>两者均支持重定向，goframe还支持通过RedirectBack返回到上一个页面</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=20086855">goframe Redirect</a></p><h2 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h2><p>goframe提供Exit，ExitAll,ExitHook用于中断当前执行的逻辑方法，其底层使用的是 panic，recover 机制实现。gin目前没有原生提供该功能。</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=1114204">goframe Exit控制</a></p><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>goframe 提供 ServeFileDownload 方法用于文件流式下载</p><p>gin需自行实现</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=20086853">goframe 文件下载</a></p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><ul><li>goframe 中的cookie是一个对象，对象还封装了 sessionId相关的方法</li><li>gin 的 cookie 比较简单，只是一个字符串</li></ul><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><ul><li>goframe 通过request 获取 session，gin则是通过在中间件处引入<code>gin-contrib/sessions</code>库来实现</li><li>都支持把session放在cookie、redis、memcached、MongoDB等中。</li></ul><h1 id="HTTPClient"><a href="#HTTPClient" class="headerlink" title="HTTPClient"></a>HTTPClient</h1><p>goframe 自带，gin则是由 net&#x2F;http 提供</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据返回&quot;&gt;&lt;a href=&quot;#数据返回&quot; class=&quot;headerlink&quot; title=&quot;数据返回&quot;&gt;&lt;/a&gt;数据返回&lt;/h1&gt;&lt;h2 id=&quot;JSON-x2F-XML支持&quot;&gt;&lt;a href=&quot;#JSON-x2F-XML支持&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>goframe与gin对比(三) 请求输入</title>
    <link href="https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E4%B8%89)%20%E8%AF%B7%E6%B1%82%E8%BE%93%E5%85%A5/"/>
    <id>https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E4%B8%89)%20%E8%AF%B7%E6%B1%82%E8%BE%93%E5%85%A5/</id>
    <published>2021-10-28T10:50:36.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="请求输入"><a href="#请求输入" class="headerlink" title="请求输入"></a>请求输入</h1><h2 id="复杂参数"><a href="#复杂参数" class="headerlink" title="复杂参数"></a>复杂参数</h2><h3 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h3><p>同名参数提交格式形如：k&#x3D;v1&amp;k&#x3D;v2, goframe是后续的变量值将会覆盖前面的变量值，而gin因为用的标准库net&#x2F;http, 提交的同名参数将会被转换为字符串数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gogf/gf/frame/g&quot;</span><br><span class="line">&quot;github.com/gogf/gf/net/ghttp&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s := g.Server()</span><br><span class="line">s.BindHandler(&quot;/&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">r.Response.Write(r.Get(&quot;name&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">s.SetPort(8199)</span><br><span class="line">s.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8199/?name=john&amp;name=smith</code>, 得到<code>smith</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(&quot;/&quot;, func(c *gin.Context) &#123;</span><br><span class="line">name := c.Query(&quot;name&quot;)</span><br><span class="line">nameArray := c.QueryArray(&quot;name&quot;)</span><br><span class="line">c.String(http.StatusOK, fmt.Sprintf(&quot;hello %s &quot;, name))</span><br><span class="line">c.String(http.StatusOK, fmt.Sprintf(&quot;hello %s %s&quot;, nameArray[0], nameArray[1]))</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/?array=john&amp;array=smith</code>, 得到<code>hello john hello john smith</code></p><h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>数组参数提交格式形如：k[]&#x3D;v1&amp;k[]&#x3D;v2, goframe 与 gin 相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(&quot;/&quot;, func(c *gin.Context) &#123;</span><br><span class="line">// http://localhost:8080/?array[]=john&amp;array[]=smith</span><br><span class="line">array := c.QueryArray(&quot;array[]&quot;)</span><br><span class="line">c.String(http.StatusOK, fmt.Sprintf(&quot;hello %s %s&quot;, array[0], array[1]))</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost?array[]=john&amp;array[]=smith</code>, 得到<code>[&quot;john&quot;,&quot;smith&quot;]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gogf/gf/frame/g&quot;</span><br><span class="line">&quot;github.com/gogf/gf/net/ghttp&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s := g.Server()</span><br><span class="line">s.BindHandler(&quot;/&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">r.Response.Write(r.Get(&quot;array&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">s.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/?array[]=john&amp;array[]=smith</code>, 得到<code>hello john smith</code></p><h2 id="对象处理"><a href="#对象处理" class="headerlink" title="对象处理"></a>对象处理</h2><p>可将数据解析与绑定分为 json, xml, 表单, uri 等几种。goframe和gin均支持这几种数据的绑定与解析。</p><p>goframe推荐使用 parse转换来实现struct的转换。可参考<a href="https://goframe.org/pages/viewpage.action?pageId=1114185">goframe请求输入-对象处理文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gogf/gf/frame/g&quot;</span><br><span class="line">&quot;github.com/gogf/gf/net/ghttp&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type RegisterReq struct &#123;</span><br><span class="line">Name  string</span><br><span class="line">Pass  string `p:&quot;password1&quot;`</span><br><span class="line">Pass2 string `p:&quot;password2&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RegisterRes struct &#123;</span><br><span class="line">Code  int         `json:&quot;code&quot;`</span><br><span class="line">Error string      `json:&quot;error&quot;`</span><br><span class="line">Data  interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s := g.Server()</span><br><span class="line">s.BindHandler(&quot;/register&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">var req *RegisterReq</span><br><span class="line">if err := r.Parse(&amp;req); err != nil &#123;</span><br><span class="line">r.Response.WriteJsonExit(RegisterRes&#123;</span><br><span class="line">Code:  1,</span><br><span class="line">Error: err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">r.Response.WriteJsonExit(RegisterRes&#123;</span><br><span class="line">Data: req,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">s.SetPort(8199)</span><br><span class="line">s.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://127.0.0.1:8199/register?name=john&amp;password1=123&amp;password2=456</code>, 得到<code>&#123;&quot;code&quot;:0,&quot;error&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;Name&quot;:&quot;john&quot;,&quot;Pass&quot;:&quot;123&quot;,&quot;Pass2&quot;:&quot;456&quot;&#125;&#125;</code></p><p>gin 和 goframe 类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type RegisterReq struct &#123;</span><br><span class="line">Name  string</span><br><span class="line">Pass  string `form:&quot;password1&quot; binding:&quot;required&quot;`</span><br><span class="line">Pass2 string `form:&quot;password2&quot; binding:&quot;required&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RegisterRes struct &#123;</span><br><span class="line">Code  int         `json:&quot;code&quot;`</span><br><span class="line">Error string      `json:&quot;error&quot;`</span><br><span class="line">Data  interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(&quot;/register&quot;, func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">var req RegisterReq</span><br><span class="line">if err := c.ShouldBind(&amp;req); err != nil &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, RegisterRes&#123;</span><br><span class="line">Code:  1,</span><br><span class="line">Error: err.Error(),</span><br><span class="line">Data:  req&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, RegisterRes&#123;Data: req&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/register?name=john&amp;password1=pwd1&amp;password2=pwd2</code>，可得到<code>&#123;&quot;code&quot;:0,&quot;error&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;Name&quot;:&quot;&quot;,&quot;Pass&quot;:&quot;pwd1&quot;,&quot;Pass2&quot;:&quot;pwd2&quot;&#125;&#125;</code></p><p>展示的案例是绑定get请求的query参数，其他的情况可参考</p><p><a href="https://github.com/gin-gonic/gin#only-bind-query-string">只绑定Get参数 官方</a><br><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949428">只绑定Get参数 中文</a><br><a href="https://github.com/gin-gonic/gin#bind-query-string-or-post-data">绑定Get参数或者Post参数 官方</a><br><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949429">绑定Get参数或者Post参数 中文</a><br><a href="https://github.com/gin-gonic/gin#bind-uri">绑定uri 官方</a><br><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949430">绑定uri 中文</a><br><a href="https://github.com/gin-gonic/gin#bind-html-checkboxes">绑定HTML复选框 官方</a><br><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949431">绑定HTML复选框 中文</a><br><a href="https://github.com/gin-gonic/gin#multiparturlencoded-binding">绑定Post参数 官方</a><br><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949432">绑定Post参数 中文</a><br><a href="https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/gin%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A/%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A.html">表单数据解析和绑定</a><br><a href="https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/gin%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A/uri%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A.html">URI数据解析和绑定</a></p><h2 id="JSON-x2F-XML"><a href="#JSON-x2F-XML" class="headerlink" title="JSON&#x2F;XML"></a>JSON&#x2F;XML</h2><p>从GoFrame v1.11版本开始，Request对象提供了对客户端提交的JSON&#x2F;XML数据格式的原生支持。可通过 Parse 方法转换json或xml</p><p>具体案例可参考 <a href="https://goframe.org/pages/viewpage.action?pageId=1114325">GoFrame 请求输入JSON&#x2F;XML转换</a></p><p>gin也类似，gin提供 Must bind 和 Should bind 两种绑定方法，具体使用时根据 json，xml，yaml等使用不同的函数。两种绑定方法的区别在于当存在绑定错误时是否直接终止请求亦或者交由开发人员处理。</p><p>具体案例可参考<br><a href="https://github.com/gin-gonic/gin#model-binding-and-validation">模型绑定和验证 官方</a><br><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949426">模型绑定和验证 中文</a><br><a href="https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/gin%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A/json%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A.html">Json 数据解析和绑定</a></p><h2 id="请求校验"><a href="#请求校验" class="headerlink" title="请求校验"></a>请求校验</h2><p>goframe 和 gin 的校验方式形式上差不多，都支持自定义的校验模式，不同的是，goframe还支持将错误转换为错误接口，这样可以控制不一次性输出全部错误，一次性输出全部错误有时候对用户并不友好。诸如每次只输出第一个校验错误。</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=1114244">goframe 请求校验示例</a><br><a href="https://github.com/gin-gonic/gin#custom-validators">gin 自定义校验示例</a><br><a href="https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/%E7%BB%93%E6%9E%84%E4%BD%93%E9%AA%8C%E8%AF%81.html">gin 结构体验证</a><br><a href="https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81.html">gin 自定义验证</a></p><h2 id="默认值绑定"><a href="#默认值绑定" class="headerlink" title="默认值绑定"></a>默认值绑定</h2><p>goframe 和 gin 都支持默认值绑定，uri，query,form等都是支持默认值的。默认值绑定的一个常用场景是，列表分页时的每页默认条数和当前页数的赋值。</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=3671922">goframe 默认值绑定 示例</a></p><p>goframe支持json的默认值绑定，而gin并不能直接在结构体定义的时候设置默认值，可行的方法在实例化json时再自行设置默认值。gin官方文档中并没详细如何处理参数的默认值问题，所以我下面写个示例补充一下。</p><p>gin的uri，form等默认取值比较简单，使用 DefaultQuery 和 DefaultPostForm 即可解决默认值的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route.GET(&quot;/&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.DefaultQuery(&quot;name&quot;, &quot;john&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者，也可以在定义结构体的时候声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ListInfo struct &#123;</span><br><span class="line">Page int `form:&quot;page,default=1&quot; json:&quot;page&quot; xml:&quot;page&quot; `</span><br><span class="line">Size int `form:&quot;size,default=10&quot; json:&quot;size&quot; xml:&quot;size&quot; `</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gin设定 json 与 xml 的默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Binding from JSON</span><br><span class="line">type ListInfo struct &#123;</span><br><span class="line">Page int `form:&quot;page,default=1&quot; json:&quot;page&quot; xml:&quot;page&quot; `</span><br><span class="line">Size int `form:&quot;size,default=10&quot; json:&quot;size&quot; xml:&quot;size&quot; `</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line">// Example for binding JSON (&#123;&quot;user&quot;: &quot;manu&quot;, &quot;password&quot;: &quot;123&quot;&#125;)</span><br><span class="line">router.POST(&quot;/listJSON&quot;, func(c *gin.Context) &#123;</span><br><span class="line">json := ListInfo&#123;</span><br><span class="line">Page: 1,</span><br><span class="line">Size: 10,</span><br><span class="line">&#125;</span><br><span class="line">if err := c.ShouldBindJSON(&amp;json); err != nil &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, json)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Example for binding XML (</span><br><span class="line">//&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">//&lt;root&gt;</span><br><span class="line">//&lt;page&gt;1&lt;/page&gt;</span><br><span class="line">//&lt;size&gt;10&lt;/size&gt;</span><br><span class="line">//&lt;/root&gt;)</span><br><span class="line">router.POST(&quot;/listXML&quot;, func(c *gin.Context) &#123;</span><br><span class="line">xml := ListInfo&#123;</span><br><span class="line">Page: 1,</span><br><span class="line">Size: 10,</span><br><span class="line">&#125;</span><br><span class="line">if err := c.ShouldBindXML(&amp;xml); err != nil &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, xml)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Listen and serve on 0.0.0.0:8080</span><br><span class="line">router.Run(&quot;:8080&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义变量-与-Context"><a href="#自定义变量-与-Context" class="headerlink" title="自定义变量 与 Context"></a>自定义变量 与 Context</h2><p>开发者可以在请求中自定义一些变量设置, goframe 和 gin 都支持。</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=1114273">goframe文档 自定义变量</a><br><a href="https://goframe.org/pages/viewpage.action?pageId=1114211">goframe文档 Context</a><br><a href="https://github.com/gin-gonic/gin#custom-middleware">gin中间件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;请求输入&quot;&gt;&lt;a href=&quot;#请求输入&quot; class=&quot;headerlink&quot; title=&quot;请求输入&quot;&gt;&lt;/a&gt;请求输入&lt;/h1&gt;&lt;h2 id=&quot;复杂参数&quot;&gt;&lt;a href=&quot;#复杂参数&quot; class=&quot;headerlink&quot; title=&quot;复杂参数&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>goframe与gin对比(二) 路由管理</title>
    <link href="https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E4%BA%8C)%20%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/"/>
    <id>https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E4%BA%8C)%20%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/</id>
    <published>2021-10-28T10:49:58.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><p>goframe 的动态路由的底层数据结构是由层级哈希表和双向链表构建的路由树。gin 路由算法是前缀树(Trie), 时间复杂度是 O(n)。</p><p>可参考 <a href="https://segmentfault.com/a/1190000040124367">gin的路由算法</a></p><p>当gin出现路由规则重复时，会报错。而goframe则是按照深度优先策略进行优先级控制。主要规则如下：</p><ol><li>层级越深的规则优先级越高；</li><li>同一层级下，精准匹配优先级高于模糊匹配；</li><li>同一层级下，模糊匹配优先级：字段匹配 &gt; 命名匹配 &gt; 模糊匹配</li></ol><p>gin和goframe都支持命名匹配规则、模糊匹配规则，不建议使用模糊匹配规则，容易引起冲突。</p><p>gin 不支持 goframe中的字段匹配规则，但实际上也可以做到类似效果</p><p>路由匹配参考文档</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=1114257">goframe路由管理-路由规则</a></p><p><a href="https://github.com/gin-gonic/gin#parameters-in-path">gin路由规则</a></p><p>本节gin示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(&quot;/:name&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.String(200, c.FullPath())</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(&quot;/:name/update&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.String(200, c.FullPath())</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(&quot;/:name/:action&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.String(200, c.FullPath())</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(&quot;/:name/*any&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.String(200, c.FullPath())</span><br><span class="line">&#125;) //因与上面规则产生冲突，go run 时报错</span><br><span class="line">// r.GET(&quot;/:name/list/&#123;field&#125;.html&quot;, func(c *gin.Context) &#123;</span><br><span class="line">// c.String(200, c.FullPath())</span><br><span class="line">// &#125;) //暂不支持该匹配模式，可采用下面这种模式代替</span><br><span class="line">r.GET(&quot;/:name/hello-:action&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.String(200, c.FullPath())</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节goframe示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gogf/gf/frame/g&quot;</span><br><span class="line">&quot;github.com/gogf/gf/net/ghttp&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s := g.Server()</span><br><span class="line">s.BindHandler(&quot;/:name&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">r.Response.Writeln(r.Router.Uri)</span><br><span class="line">&#125;)</span><br><span class="line">s.BindHandler(&quot;/:name/update&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">r.Response.Writeln(r.Router.Uri)</span><br><span class="line">&#125;)</span><br><span class="line">s.BindHandler(&quot;/:name/:action&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">r.Response.Writeln(r.Router.Uri)</span><br><span class="line">&#125;)</span><br><span class="line">s.BindHandler(&quot;/:name/*any&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">r.Response.Writeln(r.Router.Uri)</span><br><span class="line">&#125;)</span><br><span class="line">s.BindHandler(&quot;/user/list/&#123;field&#125;.html&quot;, func(r *ghttp.Request) &#123;</span><br><span class="line">r.Response.Writeln(r.Router.Uri)</span><br><span class="line">&#125;)</span><br><span class="line">s.SetPort(8199)</span><br><span class="line">s.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h2><p>goframe 路由注册有函数注册和对象注册两种，并支持分组路由</p><p>可参考 <a href="https://goframe.org/pages/viewpage.action?pageId=1114479">goframe路由注册文档</a></p><p>gin 在小型项目情况下，可简单使用类似函数注册的方法，当项目规模变大后，可以对路由进行拆分，形成单独的文件或者包。这时，可以在单独的文件中，完成路由注册工作。当项目继续膨胀，可以通过定义多个路由文件来注册路由。</p><p>如果项目规模实在太大，可以根据业务线拆分路由，将代码拆分到多个文件中，并利用Include函数注册子模块中定义的路由，利用Init函数初始化路由。</p><p>可参考 <a href="https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/gin%E8%B7%AF%E7%94%B1/%E8%B7%AF%E7%94%B1%E6%8B%86%E5%88%86%E4%B8%8E%E6%B3%A8%E5%86%8C.html">gin路由拆分与注册</a></p><p>goframe 和 gin 都支持路由分组功能</p><p>路由分组可以更加高效的管理一系列URL，诸如统一前缀，鉴权校验，错误处理等，建议使用。</p><p>goframe 和 gin 都可以通过在路由组中添加中间件，来添加诸如鉴权，日志记录等特性。goframe还可以通过HOOK的方式注册路由。</p><p>[goframe分组路由文档]（<a href="https://goframe.org/pages/viewpage.action?pageId=1114479%EF%BC%89">https://goframe.org/pages/viewpage.action?pageId=1114479）</a><br><a href="https://www.bookstack.cn/read/goframe-1.11/net-ghttp-router-hook.md">goframe HOOK事件回调</a><br><a href="https://github.com/gin-gonic/gin#grouping-routes">gin路由分组</a></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>原理类似aop，亦或者，虽然gin将其描述为middleware，但个人认为称呼为拦截器更加合适。</p><p>goframe和gin都有全局中间件和局部中间件的概念，能实现的功能类似。</p><p>下面goframe中间件的文档中，有5个中间件示例，分别是，允许跨域请求、请求鉴权处理、鉴权例外处理、统一的错误处理、自定义日志处理，均是常用中间件的范例，值得一看。</p><p><a href="https://goframe.org/pages/viewpage.action?pageId=1114315">goframe中间件文档</a><br><a href="https://www.bookstack.cn/read/goframe-1.11/net-ghttp-router-middleware.md">goframe中间件设计</a><br><a href="https://github.com/gin-gonic/gin#using-middleware">gin中间件文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由管理&quot;&gt;&lt;a href=&quot;#路由管理&quot; class=&quot;headerlink&quot; title=&quot;路由管理&quot;&gt;&lt;/a&gt;路由管理&lt;/h1&gt;&lt;h2 id=&quot;路由规则&quot;&gt;&lt;a href=&quot;#路由规则&quot; class=&quot;headerlink&quot; title=&quot;路由规则&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>goframe与gin对比(一) 综述</title>
    <link href="https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E4%B8%80)%20%E7%BB%BC%E8%BF%B0/"/>
    <id>https://fenixadar.github.io/2021/10/28/goframe%E4%B8%8Egin%E5%AF%B9%E6%AF%94(%E4%B8%80)%20%E7%BB%BC%E8%BF%B0/</id>
    <published>2021-10-28T10:49:15.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="整体优缺点"><a href="#整体优缺点" class="headerlink" title="整体优缺点"></a>整体优缺点</h2><p>可以把goframe比作 windows，整体性强，结合都高，开箱即用。而gin，则类似于linux，各组件小而独立，通过融合各个组件，完全可以组成一个比goframe更好的二开平台，但技术要求高，时间跨度长。</p><p>goframe 优点 </p><ul><li>整体全面，基本覆盖建设企业级系统所需的组件</li><li>文档全面具体，基本上可以在文档中找到答案。</li></ul><p>goframe 缺点</p><ul><li>有停止维护的风险</li><li>较封闭，类似微软DotNet，平台涉及各个方面，一旦出现bug，无法整体替换，第三方组件兼容性尚不明确</li><li>虽然官方文档全面，但公网上文档比较少</li></ul><p>gin 优点</p><ul><li>较轻量级，事实上是加了路由和模板功能的net&#x2F;http库</li><li>第三方组件兼容性好，可以自由选择第三方组件</li></ul><p>gin 缺点</p><ul><li>过于轻量级，初学者初期需要花时间去寻找学习第三方组件的使用方式，并将其融合到项目中</li><li>官方文档较简单</li><li>没有工程化的组件，需要自行研究引入。</li></ul><h2 id="核心关注点"><a href="#核心关注点" class="headerlink" title="核心关注点"></a>核心关注点</h2><h3 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h3><ul><li>goframe 全面具体。</li><li>gin 官方文档过于简单，有基础的示例，但不全。具体问题需要大量求助于google</li></ul><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><ul><li>goframe 使用自带的 gdb 实现</li><li>gin 可通过引入第三方(如gorm)实现</li></ul><h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><p>路由规则和注册方法有一些区别，goframe 路由存在优先级，会按照优先级排序，gin 则是出现冲突时直接报错。中间件方面能实现的功能类似。</p><h3 id="请求输入"><a href="#请求输入" class="headerlink" title="请求输入"></a>请求输入</h3><ul><li>对待输入参数的顺序处理有一些区别。主要是因为底层依赖的库不一样，但最终能达到的结果差不多。</li><li>转换 对象，json，xml 为结构体相差不多，gin不支持 json，xml 参数绑定默认值，但影响不大，可用其他方法实现赋予默认值。</li><li>都支持ctx中自定义变量</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>goframe 中的cookie是一个对象，对象还封装了 sessionId相关的方法</li><li>gin 的 cookie 比较简单，只是一个字符串</li></ul><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><ul><li>goframe 通过request 获取 session，gin则是通过在中间件处引入<code>gin-contrib/sessions</code>库来实现</li><li>都支持把session放在cookie、redis、memcached、MongoDB等中。</li></ul><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><ul><li>goframe自带</li><li>gin 无</li></ul><h3 id="日志组件"><a href="#日志组件" class="headerlink" title="日志组件"></a>日志组件</h3><ul><li>goframe 功能较为全面，涵盖日志级别，错误堆栈打印，链式操作等特性。</li><li>gin 使用中间件，可以将日志输出，只能完成基本功能，这种做法可能会有性能瓶颈，需引入第三方，增强功能，提高性能。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>goframe 可输出错误堆栈，添加错误码，以对开发者友好的方式输出</li><li>gin则是以go原生异常抛出方式处理。</li></ul><h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><ul><li>goframe 自带</li><li>gin 默认引入第三方解决</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>goframe 自带，支持基本类型，map，结构体。高级用法支持通过scan方法实现任意参数到struct&#x2F;struct数组&#x2F;map&#x2F;map数组的转换，并且根据开发者输入的转换目标参数自动识别执行转换。支持通过自定义类型转换规则做类型转换。</li><li>gin 无</li></ul><h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><ul><li>goframe 自带，支持内存缓存，redis适配，通过缓存适配实现存储到对应的cache对象上。</li><li>gin 无</li></ul><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>不使用，未对比</p><h3 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h3><ul><li>goframe 自带OpenTelemetry实施标准支持</li><li>gin 无</li></ul><h3 id="微服务支持"><a href="#微服务支持" class="headerlink" title="微服务支持"></a>微服务支持</h3><ul><li>除链路跟踪外，无区别。</li><li>当前都尚未考虑到大规模微服务场景支持。</li></ul><h3 id="实用工具类"><a href="#实用工具类" class="headerlink" title="实用工具类"></a>实用工具类</h3><ul><li>goframe自带，较全</li><li>gin 无</li></ul><h3 id="构建部署流程"><a href="#构建部署流程" class="headerlink" title="构建部署流程"></a>构建部署流程</h3><p>无区别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h1&gt;&lt;h2 id=&quot;整体优缺点&quot;&gt;&lt;a href=&quot;#整体优缺点&quot; class=&quot;headerlink&quot; title=&quot;整体优缺点&quot;&gt;&lt;/a&gt;整体优缺</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用触发器记录表内数据变更日志</title>
    <link href="https://fenixadar.github.io/2021/10/26/%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AE%B0%E5%BD%95%E8%A1%A8%E5%86%85%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4%E6%97%A5%E5%BF%97/"/>
    <id>https://fenixadar.github.io/2021/10/26/%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AE%B0%E5%BD%95%E8%A1%A8%E5%86%85%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4%E6%97%A5%E5%BF%97/</id>
    <published>2021-10-26T06:28:53.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、遇到的问题"><a href="#一、遇到的问题" class="headerlink" title="一、遇到的问题"></a>一、遇到的问题</h2><p>因为系统升级改造，遇到的问题是，新老两个数据库的两张表需要做数据同步，这两张表的表结构不完全相同，同步时会用类似nifi这种etl工具做转换。由于是线上系统，不可随意对原有的表结构进行变更。由于是老旧系统，业务繁杂，短时间内无法理清代码逻辑，也就不能从代码层做处理。</p><p>用nifi做数据同步时，发现特别是数据删除这种场景，会需要全表扫描做对比，得到被删掉的项，而后在另外一张表中做删除动作，这种方法性能极差。</p><p>于是，想到在数据库层面利用触发器记录变化的数据的id，同步时针对id进行同步，可大大提高性能。</p><h2 id="二、触发器文档"><a href="#二、触发器文档" class="headerlink" title="二、触发器文档"></a>二、触发器文档</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>CREATE<br>    [DEFINER &#x3D; user]<br>    TRIGGER trigger_name<br>    trigger_time trigger_event<br>    ON tbl_name FOR EACH ROW<br>    [trigger_order]<br>    trigger_body<br>trigger_time: { BEFORE | AFTER }<br>trigger_event: { INSERT | UPDATE | DELETE }<br>trigger_order: { FOLLOWS | PRECEDES } other_trigger_name</p><p>触发时间有BEFORE和AFTER两种<br>触发事件，涵盖 增改删 三类，drop table，truncate table 不会激活触发器</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://dev.mysql.com/doc/refman/5.6/en/trigger-syntax.html">mysql官方文档 触发器语法和示例</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/create-trigger.html">mysql官方文档 创建触发器</a></p><p><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/trigger-syntax.html">mysql非官方中文文档 触发器语法和示例</a><br><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/create-trigger.html">mysql非官方中文文档 创建触发器</a></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><p>Cascaded foreign key actions do not activate triggers. </p></li><li><p>Within the trigger body, the OLD and NEW keywords enable you to access columns in the rows affected by a trigger. OLD and NEW are MySQL extensions to triggers; they are not case-sensitive.<br>In a DELETE trigger, only OLD.col_name can be used; there is no new row.<br>In an UPDATE trigger, you can use OLD.col_name to refer to the columns of a row before it is updated and NEW.col_name to refer to the columns of the row after it is updated.<br>In an INSERT trigger, only NEW.col_name can be used; there is no old row. </p></li><li><p>触发器执行失败导致的事务回滚</p></li></ul><h2 id="三、准备"><a href="#三、准备" class="headerlink" title="三、准备"></a>三、准备</h2><p>测试版本 mysql 5.6.51</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_swedish_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">512</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_swedish_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  `created_at` <span class="type">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updated_at` <span class="type">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `deleted_at` <span class="type">timestamp</span>(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;删除时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_user_log`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user_log`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;t_user表id&#x27;</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">15</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新类型，insert or update or delete&#x27;</span>,</span><br><span class="line">  `create_at` <span class="type">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><h2 id="四、INSERT-触发器"><a href="#四、INSERT-触发器" class="headerlink" title="四、INSERT 触发器"></a>四、INSERT 触发器</h2><p>在t_user表中建立insert触发器，当往t_user表中插入数据时，同时往t_user_log表插入一条数据。</p><p>可通过’new.列名’获取插入行的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tr_t_user_insert AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> t_user <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t_user_log(user_id, type) <span class="keyword">values</span>(new.id, <span class="string">&#x27;insert&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(name, remark) <span class="keyword">VALUES</span>(<span class="string">&#x27;name1&#x27;</span>,<span class="string">&#x27;remark1&#x27;</span>), (<span class="string">&#x27;name2&#x27;</span>,<span class="string">&#x27;remark2&#x27;</span>), (<span class="string">&#x27;name3&#x27;</span>,<span class="string">&#x27;remark3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行后在t_user_log表中会出现触发器插入的三条记录。</p><h2 id="五、UPDATE-触发器"><a href="#五、UPDATE-触发器" class="headerlink" title="五、UPDATE 触发器"></a>五、UPDATE 触发器</h2><p>在t_user表中建立update触发器，当更新t_user表中数据时，同时往t_user_log表插入一条数据。</p><p>可通过’new.列名’获取更新的新数据，通过’old.列名’获取更新前的老数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tr_t_user_update AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> t_user <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF new.updated_at <span class="operator">&lt;&gt;</span> old.updated_at <span class="keyword">THEN</span></span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t_user_log(user_id, type) <span class="keyword">values</span>(new.id, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t_user_log(user_id, type) <span class="keyword">values</span>(new.id, <span class="string">&#x27;manual update&#x27;</span>);</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>更新数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">update</span> t_user <span class="keyword">set</span> remark<span class="operator">=</span><span class="string">&#x27;remark11&#x27;</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;name1&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> t_user <span class="keyword">set</span> remark<span class="operator">=</span><span class="string">&#x27;remark22&#x27;</span>, updated_at<span class="operator">=</span>now() <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;name2&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行后在t_user_log表中会出现触发器插入的2条记录。</p><h2 id="六、DELETE-触发器"><a href="#六、DELETE-触发器" class="headerlink" title="六、DELETE 触发器"></a>六、DELETE 触发器</h2><p>在t_user表中建立delete触发器，当删除t_user表中数据时，同时往t_user_log表插入一条数据。</p><p>通过’old.列名’获取删除的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tr_t_user_delete AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> t_user <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> t_user_log(user_id, type) <span class="keyword">values</span>(old.id, <span class="string">&#x27;delete&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;name1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行后在t_user_log表中会出现触发器插入的1条记录。</p><h2 id="七、后话"><a href="#七、后话" class="headerlink" title="七、后话"></a>七、后话</h2><p>本方法在《高性能MYSQL》一书的触发器一节有提及。虽然在开发过程中，已有的开发经验是应尽量避免甚至不使用触发器。但是在某些特定的场景，诸如本文描述的场景问题，使用触发器记录变更日志，加上触发器本身并不会改动业务逻辑，个人认为可以考虑临时使用触发器解决问题。当然,本文的场景，还有另外一种方法是，使用 canal + binlog 的方式同步数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、遇到的问题&quot;&gt;&lt;a href=&quot;#一、遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;一、遇到的问题&quot;&gt;&lt;/a&gt;一、遇到的问题&lt;/h2&gt;&lt;p&gt;因为系统升级改造，遇到的问题是，新老两个数据库的两张表需要做数据同步，这两张表的表结构不完全相同，同</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>解决执行&quot;go build&quot;时报&quot;Host key verification failed.&quot;的错误</title>
    <link href="https://fenixadar.github.io/2021/10/20/%E8%A7%A3%E5%86%B3%E6%89%A7%E8%A1%8Cgo%20build%E6%97%B6%E6%8A%A5Host%20key%20verification%20failed%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://fenixadar.github.io/2021/10/20/%E8%A7%A3%E5%86%B3%E6%89%A7%E8%A1%8Cgo%20build%E6%97%B6%E6%8A%A5Host%20key%20verification%20failed%E7%9A%84%E9%94%99%E8%AF%AF/</id>
    <published>2021-10-20T03:52:31.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决执行”go-build”时报”Host-key-verification-failed-”的错误"><a href="#解决执行”go-build”时报”Host-key-verification-failed-”的错误" class="headerlink" title="解决执行”go build”时报”Host key verification failed.”的错误"></a>解决执行”go build”时报”Host key verification failed.”的错误</h1><p>go版本 1.16+，项目存在引用私有库的情况，在执行”go build”时，总是报如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">go: xx.xxx.com/xxx/xxx@v0.1.0: reading xx.xxx.com/xxx/xxx/go.mod at revision v0.1.0: git ls-remote -q origin in /Users/xxx/go/pkg/mod/cache/vcs/xxxxx: exit status 128:</span><br><span class="line">        Host key verification failed.</span><br><span class="line">        fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">        Please make sure you have the correct access rights</span><br><span class="line">        and the repository exists.</span><br></pre></td></tr></table></figure><p>google该错误，网上可以找到很多回答是说 known_host的指纹问题，但是单纯使用 ssh -T xx.xxx.com，并没有解决该问题。</p><p>通过 go build -x 可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/xxx/go/pkg/mod/cache/vcs/xxxxx for git3 ssh://git@abc.xxx.com:8080/xxx/xxx.git</span><br></pre></td></tr></table></figure><p>其实最后会到 abc.xxx.com:8080 拉取，所以我们应该解决的是添加 abc.xxx.com 的指纹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://git@abc.xxx.com:8080/xxx/xxx.git</span><br><span class="line">Cloning into &#x27;xxx&#x27;...</span><br><span class="line">The authenticity of host &#x27;[abc.xxx.com]:8080 ([10.1.1.100]:8080)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:xxxxx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? </span><br></pre></td></tr></table></figure><p>回答 yes 后，known_host中就会出现 abc.xxx.com:8080 的指纹，再执行 go build 即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解决执行”go-build”时报”Host-key-verification-failed-”的错误&quot;&gt;&lt;a href=&quot;#解决执行”go-build”时报”Host-key-verification-failed-”的错误&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>个人虚拟化集群搭建教程</title>
    <link href="https://fenixadar.github.io/2021/06/04/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>https://fenixadar.github.io/2021/06/04/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2021-06-04T06:58:20.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><ul><li>本教程最重要还是在建设理念与思路，部分步骤中，因网上可轻松查到的资料，故会省略不详谈。</li><li>实际搭建过程中，几乎每个步骤均有多重选择，笔者会适当的描述这些选择项。</li><li>本文着重讲解利用家用组装机+pfsense软路由的方式搭建集群。</li></ul><h2 id="二、为什么要搭建个人虚拟化集群？"><a href="#二、为什么要搭建个人虚拟化集群？" class="headerlink" title="二、为什么要搭建个人虚拟化集群？"></a>二、为什么要搭建个人虚拟化集群？</h2><p>做为一个开发，你是不是有以下几个痛点：</p><ul><li>MQ，mysql，redis等开发用软件越装越多，已经感觉到计算机明显变卡</li><li>开发环境软件本身以及其下载的文件诸如maven缓存等，占用大量磁盘空间，硬盘严重告急</li><li>开发软件所需配置也越来越多，已经记不清自己曾经配置过什么，甚至出现配置互相覆盖影响的问题</li><li>为了做技术架构探索选型，不得不在本地先安装许多软件，设置很多配置，完结后还得删掉以免影响系统运行速度，浪费诸多时间。</li><li>安装了vmware workstation，就为了能跑几个linux系统做实验，导致计算机内存告急，运行缓慢。</li><li>出差时，带性能好的笔记本太重，带轻薄的本子又太卡。更麻烦的是，你得在你每台计算机上重复配置一次，有时候还会遗漏配置项导致出错。</li></ul><p>笔者也曾遇到过此类问题，并困扰了笔者很久。为了解决这个问题，我们可以提升单机的性能，但提升单机性能只能解决部分问题，并不能根本性的解决问题，诸如解决不了环境变量污染的问题。亦或者，我们也可以在云平台购买按量计费的云主机或者saas服务，此方法好处是能快速的得到你想要的机器，而且可供给的数量几乎是不限的，但缺点也很明显，如果你需要长期运行或者所需数量较多，该方法成本会变得相当高昂。</p><p><strong>笔者最终解决该问题的方案是，搭建自己的虚拟化集群。</strong></p><p>整体的网络拓扑结构很简单，如下图：</p><p><img src="/2021/06/04/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="网络拓扑结构"></p><h2 id="三、优势与劣势"><a href="#三、优势与劣势" class="headerlink" title="三、优势与劣势"></a>三、优势与劣势</h2><ol><li>优势：</li></ol><ul><li>虚拟化集群可以7x24小时不间断的提供你所需的环境。</li><li>多重选择，非常自由的配置，从网络到主机，从硬件到软件，基本上你可自主决定。</li><li>性价比较高，首次成本几千即可，后续成本基本是电费，根据你设备多少决定，低至大概30+元&#x2F;月。</li></ul><ol start="2"><li>劣势：</li></ol><ul><li>需要暴露在公网环境下，必然会遭受各种网络攻击。</li><li>可靠性问题，因为只是个人搭建，在控制成本的前提下，可靠性稍弱，但因为个人使用，影响面不大。</li><li>需要你懂得一些的基础运维和网络的知识，诸如设备选型，设备安装，防火墙配置，网络环境架设，虚拟化软件的使用等一系列技能。</li><li>如果不想托管在专业机房或者单独隔离的房间，谨慎考虑购买企业级服务器，噪音跟飞机起飞一样，芜湖。。。没听过的朋友建议上B站感受一下。</li></ul><ol start="3"><li>与生产服务器集群的区别</li></ol><ul><li>本方案，基本没有考虑高可用，所以可靠性相比真正的生产集群会偏低。</li><li>投入费用较低，1台全新的Dell服务器的价格，少说也要几万元。而家用PC一台价格在6-7千之间的，性能就相当不错了。</li><li>家用组装机没有带外管理功能，发生故障时，可能需要到现场处理。</li><li>真正的服务器噪音比较大，而家用组装机噪音比较小。</li><li>生产服务器是需要放置到无尘且带有空调的机房的。</li></ul><p>总之，可以这么理解，这个方案其实就是拿普通的机器当服务器使用。价格虽然低了，但维护成本高了，可靠性低了，只是因为个人使用，即使出现问题，影响的也只是自己而已，所以可靠性低一些可接受，个人搭建规模不会太大，维护成本总体可控。</p><h2 id="四、关键性步骤"><a href="#四、关键性步骤" class="headerlink" title="四、关键性步骤"></a>四、关键性步骤</h2><ol><li>准备公网IP与域名</li><li>购买服务器、路由器、交换机等设备</li><li>安装并配置路由器、交换机等设备</li><li>安装ESXi与vCenter</li><li>在开始愉快的玩耍之前的准备工作</li></ol><h2 id="五、准备公网IP与域名"><a href="#五、准备公网IP与域名" class="headerlink" title="五、准备公网IP与域名"></a>五、准备公网IP与域名</h2><h3 id="5-1-局域网还是广域网？"><a href="#5-1-局域网还是广域网？" class="headerlink" title="5.1 局域网还是广域网？"></a>5.1 局域网还是广域网？</h3><p>首先需要明确的是，你要搭建的虚拟化集群，是只想在局域网内使用，还是可以在广域网上连接？</p><p>先说说只是在局域网内使用，建设难度会低一些，但同时，你也丧失了诸多特性。</p><p>如你把整个集群建设在公司局域网网内，离开了公司，你就连不上集群了，或者需要依赖于第三方的设备或者软件才能连的上。当然，很多公司特别是需要做二次验证的公司，未必会同意你自行接入私人的设备。亦或者，你把集群建设在家里，情况也类似，你在公司就连不上了。</p><p>总之，笔者不推荐只搭建在局域网内，本文也只针对于可在广域网上连接的方案进行介绍。</p><h3 id="5-2-注册域名"><a href="#5-2-注册域名" class="headerlink" title="5.2 注册域名"></a>5.2 注册域名</h3><p>注册域名非常的简单，网上的教程也很多，可以在阿里云上注册一个域名并做好备案工作，本文不再赘述。</p><h3 id="5-3-准备公网IP地址"><a href="#5-3-准备公网IP地址" class="headerlink" title="5.3 准备公网IP地址"></a>5.3 准备公网IP地址</h3><p>你需要能在广域网上连接到集群，那么你必定会需要一个公网的IP地址。</p><h4 id="5-3-1-如何判断你是否拥有公网IP地址呢？"><a href="#5-3-1-如何判断你是否拥有公网IP地址呢？" class="headerlink" title="5.3.1 如何判断你是否拥有公网IP地址呢？"></a>5.3.1 如何判断你是否拥有公网IP地址呢？</h4><ul><li>通常在专业的机房，或者你能拉企业专线，那么你大概率会有固定的公网IP地址。</li><li>如果你是在家中搭建集群，利用的是家庭宽带，那么你大概率只能有动态的公网IP地址(可能需向宽带运营商申请)。</li></ul><h4 id="5-3-2-如何申请公网IP？"><a href="#5-3-2-如何申请公网IP？" class="headerlink" title="5.3.2 如何申请公网IP？"></a>5.3.2 如何申请公网IP？</h4><ul><li>如果你搭建在专业的机房，那么请联系机房管理员为你提供固定公网IP。</li><li>如果你是家庭宽带，那么你需要致电你的宽带运营商，申请获得一个公网IP，这通常需要几天时间，会有专人联系你，后续可能会有专业人员到你家中帮你配置光猫。笔者建议是，鉴于运营商提供的路由器相当一般，功能很少，而且安全性也不是很好，容易受到攻击。笔者建议自购路由器，运营商专业人员到家中时，你跟专业人员说会用自己的路由器拨号上网，专业服务人员会帮你把光猫配置好，你用自己的路由器拨号可上网即可。</li></ul><p>如果能有固定的公网IP，是最好的选择。因为你向运营商申请的公网IP，它是动态的，更换的频率各地可能不一致，也许是一周，或者是一个月。这也意味着你需要定期更新域名所绑定的IP地址。因为偶尔会出现更新不及时的情况，特别跨省连接的时候，可能会有一小段时间(可能是几秒钟到几分钟)，会出现连接不上的情况。笔者测试过，最多发现会有15分钟的中断时间。</p><h4 id="5-3-3-如何更新域名绑定IP地址？"><a href="#5-3-3-如何更新域名绑定IP地址？" class="headerlink" title="5.3.3 如何更新域名绑定IP地址？"></a>5.3.3 如何更新域名绑定IP地址？</h4><p>如果你已经有固定公网IP地址，你只需要在域名解析处一次性配置好你的IP地址即可，你可以跳过本小节。</p><p>举个例子，比如你的域名是托管在阿里云上的，你可以使用树莓派或者ESXi上的一台linux虚拟机，定时执行一个脚本，获取公网IP地址，而后利用阿里云SDK更新域名绑定的IP地址。</p><p>具体步骤如下：</p><ol><li><p>所需软件安装与环境配置<br>大致步骤如下：<br>安装 python3，virtualenv，创建隔离的python运行环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python3</span><br><span class="line">pip3 install virtualenv</span><br><span class="line">mkdir ~/ddns</span><br><span class="line">cd ~/ddns</span><br><span class="line">~/.local/bin/virtualenv venv </span><br><span class="line">source venv/bin/activate</span><br><span class="line">pip3 install requests</span><br><span class="line">pip3 install aliyun-python-sdk-alidns==2.6.29</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写Python脚本</p></li></ol><p>请参考 <a href="https://help.aliyun.com/document_detail/29777.html">https://help.aliyun.com/document_detail/29777.html</a></p><p>主要思路是获取域名当前的解析记录，和实时获取到的公网IP地址做对比，如果不一致，则更新域名的解析记录。</p><p>脚本如下，”xxx”处是需要你自行修改的部分：</p><figure class="highlight python"><figcaption><span>alidns.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.client <span class="keyword">import</span> AcsClient</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkalidns.request.v20150109.UpdateDomainRecordRequest <span class="keyword">import</span> UpdateDomainRecordRequest</span><br><span class="line"><span class="keyword">from</span> aliyunsdkalidns.request.v20150109.DescribeDomainRecordInfoRequest <span class="keyword">import</span> DescribeDomainRecordInfoRequest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime,gmtime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">client = AcsClient(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">record_id = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line">request1 = DescribeDomainRecordInfoRequest()</span><br><span class="line">request1.set_accept_format(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line">request1.set_RecordId(record_id)</span><br><span class="line">response1 = client.do_action_with_exception(request1)</span><br><span class="line">data_json = <span class="built_in">str</span>(response1, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#print(data_json)</span></span><br><span class="line">ali_record_value = json.loads(data_json)[<span class="string">&#x27;Value&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, gmtime()), <span class="string">&quot;ali record value : &quot;</span>, ali_record_value)</span><br><span class="line"></span><br><span class="line">html_text = requests.get(<span class="string">&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;</span>).text</span><br><span class="line">ip_text = re.search(<span class="string">u&quot;var returnCitySN = &#123;\&quot;cip\&quot;: \&quot;(.*?)\&quot;, \&quot;cid.*\&quot;&#125;;&quot;</span>, html_text) </span><br><span class="line">new_public_ip = ip_text.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> new_public_ip != ali_record_value :</span><br><span class="line">    request2 = UpdateDomainRecordRequest()</span><br><span class="line">    request2.set_accept_format(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line">    request2.set_RecordId(record_id)</span><br><span class="line">    request2.set_RR(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    request2.set_Type(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    request2.set_Value(new_public_ip)</span><br><span class="line">    response2 = client.do_action_with_exception(request2)</span><br><span class="line">    <span class="built_in">print</span>(strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, gmtime()), <span class="built_in">str</span>(response2, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, gmtime()), <span class="string">&quot;update complete, ali_record_value is &quot;</span>, new_public_ip)</span><br></pre></td></tr></table></figure><ol start="3"><li>编写sh脚本</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ddns</span><br><span class="line"><span class="built_in">source</span> ./venv/bin/activate</span><br><span class="line">python3 alidns.py &gt;&gt; log.txt</span><br></pre></td></tr></table></figure><ol start="4"><li>添加定时任务<br>定时任务配置为每5分钟运行一次<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*/5 * * * * sh ~/ddns/alidns.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、购买设备"><a href="#六、购买设备" class="headerlink" title="六、购买设备"></a>六、购买设备</h2><h3 id="6-1-概要"><a href="#6-1-概要" class="headerlink" title="6.1 概要"></a>6.1 概要</h3><p>搭建之初，你会需要购买一些的设备，大致有以下三大类：</p><ul><li>网络设备，如路由器，交换机，网线</li><li>服务器机柜</li><li>计算机设备，如服务器，树莓派，NAS</li></ul><h3 id="6-2-网络设备"><a href="#6-2-网络设备" class="headerlink" title="6.2 网络设备"></a>6.2 网络设备</h3><h4 id="6-2-1-路由器"><a href="#6-2-1-路由器" class="headerlink" title="6.2.1 路由器"></a>6.2.1 路由器</h4><p>这里所说的路由器可不是家用的带wifi功能的路由器，而是企业级的路由器或者工控机。某宝或者某东上面都有售卖TPLINK，华为，H3C等企业级路由器。笔者的建议是，可以购买一台工控机，自行安装pfsense软路由系统，它既有路由的功能，也有防火墙的功能，安全上能有一定的保障。</p><p><img src="/2021/06/04/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E5%80%8D%E6%8E%A7%E8%BD%AF%E8%B7%AF%E7%94%B1.png" alt="倍控软路由"></p><p>要点:</p><ul><li>不要购买普通的家用路由器，功能较少且难以保障稳定性与安全性。应该买带有线千兆网口的企业级路由器，如果买带耳朵能固定在机架上面的那就更好了</li><li>可以考虑买工控机，诸如倍控。自己安装软路由系统，诸如pfsense，iKuai，RouteOS等等。</li><li>性能上，根据自己需要的带机量而定，一般价格在大几百元到1千多的区间的即可。</li></ul><h4 id="6-2-2-交换机"><a href="#6-2-2-交换机" class="headerlink" title="6.2.2 交换机"></a>6.2.2 交换机</h4><p>要点:</p><ul><li>考虑到未来的拓展性，建议你买16口或者24口全千兆的二层交换机。</li><li>如果交换机可以上机架，那就更完美了。因为不论是16还是24口的交换机，必定会有很多条网线，不上机架的话，网线容易乱糟糟一团，不利于打理。</li><li>除非你的确有需要，否则不一定要买网管型的交换机。</li></ul><h3 id="6-3-服务器机柜"><a href="#6-3-服务器机柜" class="headerlink" title="6.3 服务器机柜"></a>6.3 服务器机柜</h3><p>如果你打算托管在机房，请跳过本小节。</p><p>不管搭建在家里，或是在公司，总会需要有个地方放置所有的设备，这时会需要一个机柜。某宝或者某东上面有很多机柜选择，而且基本都可送货到楼下。如果你不买机柜，网络、电源线必然会杂乱无章，很不好打理，各类设备所占的面积也大，所以还是购买一个机柜为佳。</p><h3 id="6-4-计算机设备"><a href="#6-4-计算机设备" class="headerlink" title="6.4 计算机设备"></a>6.4 计算机设备</h3><h4 id="6-4-1-服务器的选择与购买"><a href="#6-4-1-服务器的选择与购买" class="headerlink" title="6.4.1 服务器的选择与购买"></a>6.4.1 服务器的选择与购买</h4><p>服务器的选择非常的多样，你可以购买家用组装机当服务器使用，也可以购买真正的服务器。从大类来说，可以有以下三种方案可选择</p><ul><li><p>选择家用组装机<br>好处：价格低廉，简单粗暴，噪音小，适合家庭环境<br>坏处：长时间运行可能会有可靠性的问题，没有故障指示灯等相关的设备，难以巡检，而且因为没有带外管理，出现故障无法远程处理。体积较大，浪费机柜空间</p></li><li><p>选择塔式服务器<br>好处：一定的拓展性，各方面都比较中庸<br>坏处：性价比比机架式服务器低，体积较大，浪费机柜空间。噪音虽然没用机架式那么大，但也不小。  </p></li><li><p>选择机架式服务器<br>好处：高性能，拓展性好，体积小，可以托管在IDC机房<br>坏处：噪音大，不适合家庭环境</p></li></ul><p>注意点：<br>在你选择了一种方案后，后续最好延续使用该方案。特别的，如果你选择了家用组装机，CPU一开始买的是AMD，那么后续最好也都统一买AMD的CPU，否则会导致DRS、vSan都做不了。</p><p>关于真正的服务器，你可以买全新的，或者某宝上面也有很多二手的服务器。不过二手服务器虽然价格低，但可能会有坑，就看你敢不敢买了。</p><p>这里主要介绍下利用家用的组装机做虚拟化。网络上有很多教你购买和组装的教程，这里只说一些重点注意事项。</p><ul><li><p>如何选择CPU？<br>家用组装机的cpu，一般无非就是 Intel 和 AMD 两种，从性价比角度来看，目前的zen2、zen3架构如日中天，AMD性价比无疑比Intel更高。</p></li><li><p>如何选择主板？<br>主板尽量不要购买小板，可以选择ATX，或者E-ATX的板型，因为板型小的主板，也意味着所提供的接口少，不利于将来扩展。另外，有个特别需要注意的点是，主板上的网卡芯片，一般有”Intel”和”Realtek瑞昱”两种，如果你买的是AMD的CPU，那么对应的一般价格的主板，大概率是Realtek芯片的板载网卡，而Realtek芯片的网卡，ESXi是识别不到的，这样一来你会需要额外购买Intel芯片的网卡。</p></li><li><p>如何选择内存？<br>根据你买的CPU和主板类型不同，购买合适的内存即可。</p></li><li><p>如何选择硬盘？<br>推荐购买 nvme协议 m.2接口 的ssd硬盘，因为速度真的很快。一般来说，计算机的瓶颈点会卡在IO上面。如果磁盘空间不够，可配合购买HDD硬盘，不需要联机的数据可以放NAS。</p></li><li><p>如何选择网卡？<br>笔者的建议是无论你板载的网卡的芯片是Intel还是Realtek，你最好都额外购买一张pcie的有两个网口以上的Intel芯片的网卡。为什么要这么做呢？首先，利于远程配置(笔者有一次配置虚机网络的时，需要网卡先断线再连接到正确的虚拟网络，但在断开那张网卡后，远程就再也连不上了)，其次两个网卡利于增强可靠性，最后两个网卡才能让管理的流量和普通流量分开，彼此不会互相影响(迁移主机的时候，会有大量的管理流量产生，而如果你只有一张网卡，可能会影响到业务的正常通讯)。</p></li><li><p>如何选择显卡？<br>如果你的cpu是不带核显的，那么会需要你额外购买一张显卡，建议买一张最低配的显卡即可，我们只是需要能显示而已。当然如果你有用GPU进行计算的需求，那么可根据实际需求选择显卡。</p></li><li><p>如何选择散热器？<br>一般来说，风冷就足够使用了。如果cpu自带的风扇太弱，像Intel盒装cpu自带的小风扇就比较鸡肋，你可以自行购买风扇，价位在百元左右即可。至于是否上水冷，就看各位自己评估了，笔者的实践经验是如果搭载的不是发热量很大的CPU，又没有大量的计算需求，就不需要上水冷了。另外，请注意购买的风扇的接口是否兼容你买的cpu型号。</p></li><li><p>如何选择机箱？<br>尽量买可以装三个HDD硬盘以上的机箱。尽量不要买小型的机箱，否则后续拓展麻烦且小机箱散热效果也不好。另外，如果你有服务器机柜的话，可以考虑买机架式的机箱，3U或者4U的，肯定比买普通机箱省空间，某宝上面很多。</p></li><li><p>如何选择电源？<br>选择合适的电源即可，但要注意留一定冗余量，便于后续添加组件。选择电源未必非要追求金牌不可，功率合适，能稳定输出就好。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">配置示例：</span><br><span class="line"></span><br><span class="line">AMD 锐龙7 3700X 处理器 7nm 8核16线程 3.6GHz 65W AM4接口 盒装CPU</span><br><span class="line">微星 MAG B550M BAZOOKA火箭炮电脑主板</span><br><span class="line">金士顿 FURY 32GB DDR4 2666 台式机内存条</span><br><span class="line">航嘉 WD500K 金牌500W电脑电源</span><br><span class="line">三星 1TB SSD固态硬盘 M.2接口(NVMe协议) 970 EVO</span><br><span class="line">微星 GT710 显卡</span><br><span class="line">酷冷至尊 暴雪T400 CPU散热器 支持I10 1200、AM4 /4热管/PWM温控</span><br><span class="line">先马 鲁班1 黑色 游戏电脑主机箱</span><br></pre></td></tr></table></figure><p>该配置在21年6月价格总共在6k至7k左右。</p><h4 id="6-4-2-树莓派"><a href="#6-4-2-树莓派" class="headerlink" title="6.4.2 树莓派"></a>6.4.2 树莓派</h4><p>树莓派是一种基于linux的单片机电脑，功耗较小，适合做一些简单的任务，价格在5百元左右。如果你的IP是动态公网IP，那么你可以考虑买一台树莓派，用于执行更新域名绑定IP的任务。当然你也可以不买树莓派，在虚拟机上创建一台linux主机来运行该任务，但有个问题是，假如承载该linux虚机的计算机发生宕机等的故障，很可能会导致更新任务无法执行，进而导致你连接失败。所以，从可靠性可用性的角度上看，把此任务单独放到树莓派上是有利于增强可靠性和可用性的。</p><h4 id="6-4-3-NAS"><a href="#6-4-3-NAS" class="headerlink" title="6.4.3 NAS"></a>6.4.3 NAS</h4><p>如果你有大量文件需要存储，那么买一台NAS无疑会更加保险。如果买的是支持万兆网卡的nas，后续可以升级做存算分离。</p><h3 id="6-5-关于搭建的成本"><a href="#6-5-关于搭建的成本" class="headerlink" title="6.5 关于搭建的成本"></a>6.5 关于搭建的成本</h3><p>搭建的成本主要是第一次的购买设备的成本和平时的维护成本。<br>第一次的购买设备的成本 &#x3D; 路由器 + 交换机 + 服务器机柜 + 服务器x台数 + 树莓派 + NAS(含硬盘)<br>集群搭建后，平时的成本主要是电费和维护费。举个例子，如果你按本文的家用配置搭建服务器，在不做大量密集计算的时候，功率大概在90w左右。机器24小时开机，一度电按照5毛来算，一天的一台服务器的电费成本大概是1块出头。维护费指的是，诸如硬件损坏，比如常见的硬盘长时间运行后损坏需更换的成本。</p><h2 id="七、网络环境配置"><a href="#七、网络环境配置" class="headerlink" title="七、网络环境配置"></a>七、网络环境配置</h2><p>如果你买的是工控机想安装pfsense软路由系统，下载pfsense安装包时，记得Architecture选”AMD64 (64-bit)”，Installer选”USB Memstick Installer”，Console选”VGA”。使用pfsense的时候，我遇到过一个情况，当开机启动时VGA接口没有接入显示器，路由器工作不正常，这时候你只需要在启动路由器的时候接入显示器，等启动完成后再拔掉即可，或者你直接在某宝上面买个支持集显的VGA的伪装器。</p><p>除了pfsense之外，你也可以选择安装iKuai，RouterOS，OpenWrt等。</p><p>主要的步骤是</p><ol><li>配置wan口，家庭线路主要是配置拨号上网账号密码，企业专线可能是配置一个固定的ip即可</li><li>配置端口转发策略</li><li>配置防火墙策略</li></ol><h2 id="八、安装ESXi与vCenter"><a href="#八、安装ESXi与vCenter" class="headerlink" title="八、安装ESXi与vCenter"></a>八、安装ESXi与vCenter</h2><p>关于什么是 ESXi 与 vCenter ?<br><a href="https://docs.vmware.com/cn/VMware-vSphere/index.html">https://docs.vmware.com/cn/VMware-vSphere/index.html</a></p><p>你需要在新装的电脑上安装 ESXi，安装后，将机器连接到交换机上。注意，你需要另一台pc机或者mac同时接到交换机上，这样你才能访问ESXi的web页面。<br>具体怎么安装ESXi，网上已经有很多教程，我不再赘述。</p><ul><li><p>是否一定要安装vCenter？<br>答案是不一定要安装的，如果你有2台以上，或者单台机器但内存充足，但笔者建议安装。如果你只是简单使用，不需要经常创建虚机，那么不装vCenter也无妨。<br>vCenter能提供的是更多的配置项，最重要的是能把虚机转成模板，这样你每次新建机器就不用重新做各种配置，而是从模板直接生成虚机，大大减少交付一台虚机的时间。</p></li><li><p>是否需要组DRS或者vSan？<br>都不一定。组vSan的前提是3台以上的机器，且每台机器上都至少有1个SSD和3个HDD硬盘。到目前为止，我们所有的机器都是没有组raid的，硬盘损坏的时候会有丢失数据的风险，如果你对可靠性可用性和数据的安全性有一定的要求，那么你可以考虑组vSan集群，或者你可以利用nas+万兆网络做存算分离。</p></li></ul><h2 id="九、在开始愉快的玩耍之前"><a href="#九、在开始愉快的玩耍之前" class="headerlink" title="九、在开始愉快的玩耍之前"></a>九、在开始愉快的玩耍之前</h2><p>前面的步骤做完后，我们已经基本上做完了整个环境的搭建，不过别着急，以下几点值得你注意一下</p><ol><li><p>关于磁盘制备的选择<br>在新建虚拟机的自定义硬件步骤，会有磁盘制备方式的选择，建议选择”精简制备”，默认的厚置备，会导致预先把划走你设置大小的磁盘空间。<br><img src="/2021/06/04/%E4%B8%AA%E4%BA%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B2%BE%E7%AE%80%E5%88%B6%E5%A4%87.png" alt="新建虚拟机精简制备"></p></li><li><p>制作主机模板<br>你可以新创建虚拟机，安装linux系统，对系统进行安全加固等其他的初始化操作后，关机，并将主机转成模板。这样以后你新建虚拟机，就可以从模板部署了。</p></li><li><p>关于管理网络与普通网络<br>如果你有两个甚至三个以上的网口，做好kernel端口与普通network端口的隔离与高可用的配置</p></li><li><p>设计IP地址的规划方案<br>正常我们家用的时候，tplink路由器默认的网段规划是192.168.1.0&#x2F;24，不过这时候我们会面临一个问题，当你虚机越来越多的时候，IP地址可能会不够用。所以，你应该提前规划好IP地址，掩码不再使用24，你可以使用10.0.0.0&#x2F;20，这样一个网段内第一个可用IP是10.0.0.1，最后一个可用IP是10.0.15.254，一共有4094个可用IP了。你可以访问 <a href="https://www.w3cschool.cn/tools/index?name=ipcalc">https://www.w3cschool.cn/tools/index?name=ipcalc</a> 来辅助计算规划IP地址。</p></li><li><p>谨慎使用端口转发<br>你在内部搭建的各类系统，不要随意通过端口转发对外暴露，尤其是不要对0.0.0.0开放，系统难免有漏洞，容易被攻击，特别是在我们并没有专业安全防护解决方案的情况下。如果一定要对外暴露，可以考虑限制在一定的IP范围内。</p></li></ol><h2 id="十、写在最后"><a href="#十、写在最后" class="headerlink" title="十、写在最后"></a>十、写在最后</h2><p>到目前为止，你已经完成搭建工作了，接下来怎么用就看你的想象力了。以一个开发的视角来看，你可以搭建各类服务来辅助你的开发，比如搭建gitlab存储你的代码，搭建jenkins做CI&#x2F;CD，部署mysql数据库，搭建nexus服务器加速jar包下载，搭建prometheus监控虚机状态。</p><p>HAVE FUN BE HAPPY!!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本教程最重要还是在建设理念与思路，部分步骤中，因网上可轻松查到的资料，故会省略不详谈。&lt;/li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>通过SSH隧道安全建立RDP远程桌面连接（RDP over SSH tunnel）</title>
    <link href="https://fenixadar.github.io/2021/05/07/%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E5%AE%89%E5%85%A8%E5%BB%BA%E7%AB%8BRDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%EF%BC%88RDP-over-SSH-tunnel%EF%BC%89/"/>
    <id>https://fenixadar.github.io/2021/05/07/%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E5%AE%89%E5%85%A8%E5%BB%BA%E7%AB%8BRDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%EF%BC%88RDP-over-SSH-tunnel%EF%BC%89/</id>
    <published>2021-05-07T16:18:52.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<p>我有一台windows的虚拟机, 已经在路由器中对RDP的端口做了端口映射, 如此我便能在任何地方连接上这台虚拟机, 但问题也随之而来, 如何在保证易用的同时也适当的保障安全性？</p><h2 id="为什么要通过ssh隧道来建立远程桌面连接"><a href="#为什么要通过ssh隧道来建立远程桌面连接" class="headerlink" title="为什么要通过ssh隧道来建立远程桌面连接"></a>为什么要通过ssh隧道来建立远程桌面连接</h2><ol><li>RDP服务本身存在诸多风险, 不仅仅用户的弱口令问题, 还包括其本身也有诸多漏洞, 相比之下, 还是更相信SSH一些。</li><li>很多公司为了规避风险, 会在防火墙中限制3389端口的访问。但对SSH, 会宽容许多。当然, 即使安全策略没有彻底限制RDP, 这里也不建议在没有得到公司允许的情况下, 私自利用ssh隧道来建立RDP连接, 因为还是会存在诸多风险的。</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过SSH隧道安全建立RDP远程桌面连接的方法有许多种, 这里提供以下几种方法</p><ul><li>方法1 win10通过配置可以打开 OpenSSH Server, 非win10可自行下载安装,  而后通过该Server建立ssh隧道, 本文重点介绍该方法</li><li>方法2 在内网中创建另外一个能和当前win主机互访的linux主机, 再建立隧道</li><li>方法3 如果你的路由是软路由系统并支持ssh tunnel, 可以直接利用软路由建立隧道</li></ul><p>大致步骤:</p><ol><li>在win10上打开 OpenSSH server</li><li>配置ssh server, 诸如改ssh端口, 启用密钥登录, 禁用密码登录</li><li>生成ssh key, 并将公钥拷贝到指定文件夹</li><li>将密钥拷贝到另一台计算机</li><li>在另一台计算机建立ssh隧道连接win10主机</li></ol><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li><p>打开”设置”-&gt;”应用和功能”-&gt;”可选功能”, 并安装”OpenSSH Server”功能<br><img src="/2021/05/07/%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E5%AE%89%E5%85%A8%E5%BB%BA%E7%AB%8BRDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%EF%BC%88RDP-over-SSH-tunnel%EF%BC%89/1-%E5%8F%AF%E9%80%89%E5%8A%9F%E8%83%BD.png" alt="可选功能"></p></li><li><p>配置ssh server</p></li></ol><p>OpenSSH Server 的安装目录在”C:\Windows\System32\OpenSSH”, 但我们需要在”C:\ProgramData\ssh”目录下, 修改”sshd_config”文件, 如果不能直接保存, 可先拷贝出来修改后再覆盖回去。</p><ul><li>修改ssh默认端口, Port 22 改为 Port 55555</li><li>修改 PermitRootLogin 选项为 no, 即”PermitRootLogin no”</li><li>修改 PasswordAuthentication 选项为 no, 即”PasswordAuthentication no”</li><li>不注释该行 “PubkeyAuthentication yes”</li><li>不注释该行 “AuthorizedKeysFile.ssh&#x2F;authorized_keys”</li><li>注释该行 “Match Group administrators”</li><li>注释该行 “AuthorizedKeysFile <strong>PROGRAMDATA</strong>&#x2F;ssh&#x2F;administrators_authorized_keys”</li></ul><p>可参考”<a href="https://winaero.com/enable-openssh-server-windows-10/">https://winaero.com/enable-openssh-server-windows-10/</a>“</p><ol start="3"><li>生成ssh key, 并将公钥拷贝到指定文件夹</li></ol><p>生成 ssh key 有很多种做法</p><ul><li>很多程序员安装了”git extension” , 它自带了”putty key generator”可以生成key</li><li>利用OpenSSH本身的”ssh-keygen”生成, 可直接在”cmd”中键入”ssh-keygen”回车, 按照提示创建key, 最好为私钥创建一个密码。</li></ul><p><img src="/2021/05/07/%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E5%AE%89%E5%85%A8%E5%BB%BA%E7%AB%8BRDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%EF%BC%88RDP-over-SSH-tunnel%EF%BC%89/2-%E7%94%9F%E6%88%90key.png" alt="生成key"></p><p>默认”C:&#x2F;&#x2F;Users&#x2F;&#x2F;用户名&#x2F;&#x2F;.ssh&#x2F;&#x2F;id_rsa.pub”文件便是公钥, 在该文件夹中创建”authorized_keys”, 并把公钥中的文本追加”authorized_keys”文件中。</p><ol start="4"><li><p>将密钥拷贝到另一台计算机<br>你一定会需要把你生成私钥拷贝到另外这台计算机上, 无论是windows还是linux, 一般都是放到用户文件夹下的”.ssh”文件夹。<br>windows是类似”C:&#x2F;&#x2F;Users&#x2F;&#x2F;用户名&#x2F;&#x2F;.ssh”文件夹<br>linux是类似”&#x2F;home&#x2F;用户名&#x2F;.ssh”文件夹<br>macos是类似”&#x2F;Users&#x2F;用户名&#x2F;.ssh”文件夹</p></li><li><p>在另一台计算机建立ssh隧道连接win10主机</p></li></ol><ul><li>如果另一台计算机是 linux 或者 macos, 那么只需要打开”terminal”键入命令即可创建隧道, 命令类似</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@公网IP或者域名 -p 33333 -L 12345:127.0.0.1:55555 -N -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -f</span><br></pre></td></tr></table></figure><ul><li>用户名应填写win10的用户名</li><li>公网IP或者域名处应填写你的公网IP或者域名, 如果你是用路由器上网的, 应填写路由器的获取到的公网IP地址</li><li>33333是你路由器上暴露给外部的端口号</li><li>55555是路由器映射到win10的内部端口号</li><li>如果你是通过局域网内另外一台机器做隧道, 那么127.0.0.1应改为win10在内网中的IP地址</li><li>两个”-o”参数用来保证ssh隧道不会自动关闭</li><li>加 “-f” 参数, 可以让隧道在后台运行, 但同时也不方便我们关闭隧道, 若要关闭隧道, 可以先”lsof -i tcp:12345”获取PID值, 再通过”kill -9 PID值”来关闭隧道。我一般不加”-f”参数, 方便我随时关闭隧道。</li><li>“-N”参数表示只连接远程主机, 不打开远程shell</li></ul><p>而后可以下载RDP客户端, windows自带远程桌面, linux可下载”xfreerdp”, macos可自行下载微软官方的远程桌面。新建RDP连接, ip地址填写”127.0.0.1”, 端口号写”12345”, 即可连接。</p><ul><li>如果另一台计算机也是windows, 你可以像之前安装OpenSSH Server一样安装”OpenSSH Client”,或者安装开源免费的MobaXterm, 创建一个新Session, 按照下图设置即可。</li></ul><p><img src="/2021/05/07/%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E5%AE%89%E5%85%A8%E5%BB%BA%E7%AB%8BRDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%EF%BC%88RDP-over-SSH-tunnel%EF%BC%89/3-MobaXterm.png" alt="MobaXterm"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我有一台windows的虚拟机, 已经在路由器中对RDP的端口做了端口映射, 如此我便能在任何地方连接上这台虚拟机, 但问题也随之而来, 如何在保证易用的同时也适当的保障安全性？&lt;/p&gt;
&lt;h2 id=&quot;为什么要通过ssh隧道来建立远程桌面连接&quot;&gt;&lt;a href=&quot;#为什么</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《深入浅出通信原理》一句话短评</title>
    <link href="https://fenixadar.github.io/2021/03/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E3%80%8B%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9F%AD%E8%AF%84/"/>
    <id>https://fenixadar.github.io/2021/03/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E3%80%8B%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9F%AD%E8%AF%84/</id>
    <published>2021-03-05T07:08:27.000Z</published>
    <updated>2023-01-16T01:31:48.816Z</updated>
    
    <content type="html"><![CDATA[<p>这本书其实是由某论坛系列连载的内容集结而成，总体来说，两个特点，一是简单易懂，简明扼要；二是需要一定的高等数学基础，公式略多。</p><p>读这本书我并没有想要完全理解这本书的所有内容，而是根据自己所需做了解知晓即可。这本书更多的是帮助我理解网络通信层面的一些东西，诸如物理层信号衰减等的原因。</p><p>这本书我只给评了6分，一方面是因为我并非通讯行业的行业人，而评估时加入了这本书对于自己的实用性指标。另一方面，出版这本书起因是因为连载，但如果真要深入浅出通讯原理，还是应该去看教材，毕竟过于简明扼要之后，会丢失诸多细节，也是因为如此，仅需做了解的我才会选择看这本书。</p><p>评分：6 （满分为10分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作者: 陈爱军</span><br><span class="line">出版社: 清华大学出版社</span><br><span class="line">出版年: 2018年2月第1版</span><br><span class="line">页数: 351</span><br><span class="line">定价: CNY 89.00</span><br><span class="line">装帧: 平装</span><br><span class="line">ISBN: 978-7-302-48386-1</span><br></pre></td></tr></table></figure><p><img src="/2021/03/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E3%80%8B%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9F%AD%E8%AF%84/%E5%B0%81%E9%9D%A2.jpg" alt="封面"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书其实是由某论坛系列连载的内容集结而成，总体来说，两个特点，一是简单易懂，简明扼要；二是需要一定的高等数学基础，公式略多。&lt;/p&gt;
&lt;p&gt;读这本书我并没有想要完全理解这本书的所有内容，而是根据自己所需做了解知晓即可。这本书更多的是帮助我理解网络通信层面的一些东西，诸如物</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《持续交付2-0-业务引领的DevOps精要》-要点摘录与总结</title>
    <link href="https://fenixadar.github.io/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://fenixadar.github.io/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-23T02:26:59.000Z</published>
    <updated>2023-01-16T01:31:48.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概念篇"><a href="#一、概念篇" class="headerlink" title="一、概念篇"></a>一、概念篇</h1><h2 id="为什么要持续交付？"><a href="#为什么要持续交付？" class="headerlink" title="为什么要持续交付？"></a>为什么要持续交付？</h2><p>当前互联网变化非常迅速，在这个背景下，提升产品研发运营效率，快速发现新的机会并快速试错，降低试错成本已经变得非常重要。由此，带来几个问题：</p><ol><li>如何平衡软件的质量与交付速度？</li><li>如何让产品创新快速交付部署，并让团队得到反馈？</li></ol><p>我们都知道，要快速发现新机会并快速试错，就必须加快产品迭代速度，而加快迭代速度必然使得一些常规事务性占比增大，诸如测试成本，发布成本等。持续交互，即是这些问题的解决之道。</p><h2 id="软件工程的发展历史"><a href="#软件工程的发展历史" class="headerlink" title="软件工程的发展历史"></a>软件工程的发展历史</h2><p>让我们先搁置问题本身，先来回顾软件工程的发展历史。</p><ol><li><p>瀑布软件开发模型<br>1970年，Dr.Winston W.Rovce 首次提出瀑布软件开发模型，它将软件开发定义为多个阶段，每个阶段都有严格的输入和输出标准，很多人将这种开发方法称为“重型软件开发方法”。但这种方法会需在写第一行代码前，甲乙双方花费大量精力确定需求范围，编辑并审核软件需求说明书，即便如此，还是避免不了互相扯皮。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/1-1-%E7%80%91%E5%B8%83%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.jpg" alt="瀑布软件开发模型"></p></li><li><p>敏捷软件开发<br>2001年，敏捷软件开发方法出现，敏捷方法强调发挥人的主观能动性，提倡面对面沟通，拥抱变化，通过迭代和增量开发尽早交付有价值的软件。和瀑布软件开发方法对比，敏捷能更快的看到可运行的软件，而不是到交付后期才能看到。此间，持续集成作为敏捷开发中的工程实践，率先被广泛的it组织所接受，它能减少大量重复性劳动，并排除某些沟通障碍。但敏捷方法并没有解决发布间隔长的问题，以及业务与研发团队关于需求变更和研发效率的矛盾。无论是瀑布或者敏捷开发，关注的都是如何快速将需求变为可交付的软件包。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/1-2-%E8%BF%AD%E4%BB%A3%E5%BC%80%E5%8F%91-%E5%A4%9A%E6%89%B9%E6%AC%A1%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83.jpg" alt="迭代开发-多批次部署发布"></p></li><li><p>DevOps<br>2008年，DevOps萌芽，起初的想法是将敏捷实践应用于运维领域。DevOps概念本身也在不断的变化中，如下是曾经的定义</p></li></ol><blockquote><p>DevOps是一种软件工程文化和实践，旨在统一整合软件开发和软件运维。DevOps运动的主要特点是强烈倡导对构建软件的所有环节（从集成、测试、发布到部署和基础架构管理）进行全面的自动化和监控。 DevOps的目标是缩短开发周期，提高部署频率和更可靠地发布，与业务目标保持一致。</p></blockquote><p>DevOps并非一个标准、一种模式或者一套固定方法，而是一种IT组织管理的发展趋势，也就是说，通过多种方式打破IT职能部门之间的隔阂，改变IT组织内部的原有合作模式，使之更紧密结合，从而促进业务迭代速度更快。这种发展趋势将会引起IT组织内部原有角色与分工的变化，甚至范围更大，会影响到相关的业务组织。对互联网公司来说，其软件产品对业务发展起到极其关键的作用，业务结果与IT效能强关联，因此顺应这一发展趋势的动力更加明显和迫切。</p><ol start="4"><li>持续交付<br>2010年，Jez Humble 和 Dave Farley 合著了《持续交付》一书，可以称之为“持续交付1.0”。持续交付1.0提供的原则和方法是DevOps运动的具体实操指引，事实上，敏捷开发更多的是涉及产品需求方，开发工程师，测试工程师。DevOps更多的是开发、测试和运维工程师。而持续交付1.0则涉及产品需求方，研发团队，运维团队。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/1-5-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%9C%A8%E7%BB%84%E7%BB%87%E8%A7%92%E8%89%B2%E7%9A%84%E4%B8%BB%E8%A6%81%E8%A7%A6%E8%BE%BE%E7%82%B9.jpg" alt="相关概念在组织角色的主要触达点"><br>持续交付2.0是1.0的升级版，它将精益创业的最小化可行产品和持续交付1.0相结合，强调业务与IT间的快速闭环。</li></ol><h2 id="持续交付2-0核心概念与原则"><a href="#持续交付2-0核心概念与原则" class="headerlink" title="持续交付2.0核心概念与原则"></a>持续交付2.0核心概念与原则</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>企业开发软件产品的目标是创造客户价值，为此，它必须不断探索发现真正要解决的业务问题，提出科学的目标，设计最小可行解决方案。通过快速实现解决方案并从真实反馈中收集数据，以验证该问题是否得以解决。这是一个从业务问题出发，到业务问题解决的完整业务闭环，简称为持续交付“8”字环。<br>它由两个相连的环组成:第一个环为“探索环，其主要目标是识别和定义业务问题，并制订出最小可行解决方案进入第二个环；第二个环为“验证环”，其主要目标是以最快速度交付最小可行方案，可靠地收集真实反馈，并分析和验证业务问题的解决效果，以便决定下一步行动。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/1-10-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%E7%9A%84%E5%8F%8C%E7%8E%AF%E6%A8%A1%E5%9E%8B.jpg" alt="持续交付2.0的双环模型"></p><p>探索环包含4个可持续循环步骤，分别是提问、锚定、共创和精炼。</p><ol><li>提问，即定义问题。通过有针对性的提问，找出客户的具体需求，并找出具体需求后的原因，即具体需求后要解决的根本问题。在提问中形成团队期望达成的业务目标或者想要解决的业务问题。如果问题无法清晰定义，那么找到的答案自然就会有偏差。因此，在寻找答案之前，应该先清晰地定义问题。</li><li>锚定，即定义结果目标指示器。针对问题进行信息收集，经过分析，去除干扰信息，识别问题假设，得到适当的衡量指标项，并用其描述现在的状况，同时讨论并定义我们接下来的行动所期望的结果。</li><li>共创，即共同探索和创造解决或验证该问题的多种具有可行性的解决方案。</li><li>精炼，即对所有的可行试验方案进行选择，找到最小可行性解决方案，它既可能是单个方案，也可能是多个方案的组合。</li></ol><p>验证环也包含4个可持续循环的步骤，分别是构建、运行、监测和决策。</p><ol><li>构建，是指根据非数字化描述，将最小可行性解决方案准确地转换成符合质量要求的软件包。</li><li>运行，是指将达到质量要求的软件包部署到生产环境或交到用户手中，并使之为用户提供服务。</li><li>监测，是指收集生产系统中产生的数据，对系统进行监控，确保其正常运行。同时将业务数据以适当的形式及时呈现出来。</li><li>决策，是指将收集到的数据信息与探索环得出的对应目标进行对比分析，做出决策，确定下一步的方向。</li></ol><p>探索环就像是一部车子的前轮，把握前进方向。验证环则像车子的后轮，使车子平稳且驱动快速前进。它们之间相互促进，探索环产生的可行性方案规模越小，越能够提高验证环的运转速度；如果价值验证环能够提高运转速度，则有利于探索环尽早得到真实反馈，有利于快速决策，及时对前进方向进行验证或调整。</p><h3 id="4个核心原则"><a href="#4个核心原则" class="headerlink" title="4个核心原则"></a>4个核心原则</h3><p>持续交付2.0可以使得企业以可持续发展的方式，在高质量、低成本及无风险的前提下，不断缩短持续交付“8”字环周期，从而与企业外部频繁互动，获得及时且真实的反馈，最终创造更多客户价值的能力。持续交付2.0有如下4个核心原则：</p><ol><li>坚持少做<br>在咨询的过程中，最常听到的一句话就是:我们最大的问题是人力不足。”无论公司实力如何，想做的事情永远超过自己的交付能力，需求永远做不完。然而，做得多就一定有效吗？我们应该抵住“通过大量计划来构建最佳功能”的诱惑，坚持少做，想办法对新创意尽早验证。</li><li>持续分解问题<br>复杂的业务问题中一定会包含很多不确定因素，它们会影响问题解决的速度和质量。在实施解决方案之前，通过对问题的层层分解，可以让团队更了解业务，更早识别出风险。企业应该坚信，即便是很大的课题或者大范围的变更，也可以将其分解为一系列小变更，快速解决，并得到反馈，从而尽早消除风险。与其设计一大堆特性，再策划一个持续数月的一次性发布，不如持续不断地尝试新想法并各自独立发布给用户。</li><li>坚持快速反馈<br>当把问题分解以后，如果我们仍旧只是一味地埋头苦干，而忽视对每项已完成工作的结果反馈，那么就失去了由问题分解带来的另一半收益，确认风险降低或解除。只有通过快速反馈，我们才能尽早了解所完成工作的质量和效果。</li><li>持续改进并衡量<br>无论做了什么样的改进，如果无法以某种方式衡量它的结果，就无法证明真的得到了改进。在着手解决每个问题之前，我们都要找到适当的衡量方式，并将其与对应的功能需求放在同等重要的位置上，一起完成。</li></ol><h2 id="价值探索环"><a href="#价值探索环" class="headerlink" title="价值探索环"></a>价值探索环</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>探索环的目标是持续识别和定义三个有价值的假设：</p><ol><li>用户假设，即我们提供的产品服务是针对某类潜在用户人群的需求的假设；</li><li>问题假设，即目标用户群之所以有这种需求，是因为他们的确存在某些痛点（或问题）需要解决的假设；</li><li>解决方案假设，即我们提供的解决方案可以解决这些痛点或问题，而且比其他现存的解决方案都有效且高效。</li></ol><p>这3类假设中，任何一个假设不成立，都会导致我们事倍功半，甚至前尽弃。因此，我们需要选择并验证其中风险最高或最易验证的价值假设，并借助价值验证环得到数据反馈，以便深入理解用户需求，把握业务前进方向。</p><h3 id="4个关键环节"><a href="#4个关键环节" class="headerlink" title="4个关键环节"></a>4个关键环节</h3><p>为了达成探索环的目标，我们需要经历4个关键环节：</p><ol><li><p>提问<br>该环节是持续交付“8”字环的起点。其目的在于通过不断地提问，澄清客户需求背后要实现的真正目标，以便找寻更多解决问题的方法，同时也有助于团队成员从业务问题出发，充分理解业务问题。</p></li><li><p>锚定<br>“锚定”是设定目标以及目标分解的讨论过程，其目的是确定要达成的目标以及可以衡量它的指标，并能够指导后续的共创与精炼活动。对于目标的选择，应该遵循两点:一是识别价值指标，而非虚荣指标；二是指标应该可衡量且可获取，易于客观对比。</p></li><li><p>共创<br>共创是指:当我们制订了想要达到的目标后，团队为设法验证或达成目标而找出多种可行性解决方案的过程。</p></li></ol><p>共创分析方法有很多，书中列举了两个：</p><ul><li><p>量化式影响地图<br>它是用Why-who-how-What的分析法，通过结构化的显示方式，让团队寻找达成业务目标的方法。还应该了解当前的影响程度，以及对实施后达到效果的预期。也就是，从业务问题域出发，按“角色一影响一方案一量化”的顺序进行讨论，从而尽可能多地发掘出可行性解决方案。我们可以称它为“量化式影响地图”。我们有时无法马上对所有指标进行量化。此时可临时性地收集一部分数据，并进行相应的推断，通过一段时间的运行，进行指标量化的校准即可。另一种可能是希望衡量的指标较难直接量化。此时可通过一些过程指标或相近指标来替代。需要注意的是，这两种情况都存在一定的偏差，因此在数据的应用过程中，应该格外注意。</p></li><li><p>用户旅行地图<br>用户旅行地图（user journey map）是指以可视化方式，将用户与产品或服务之间的互动，按业务流分阶段呈现出来。</p></li></ul><p>在“共创”这一环节中，需要注意两个陷阱，分别是分析瘫痪（paralysis by analysis）和直觉决策（extinct by instinct）。分析瘫痪是指因为过度分析（或过度思考）而无法决策或采取行动，最终影响结果产出的一种状态。通常是由于有太多的细节选项，或者过于寻求最佳或“完美”的解决方案，并担心做出任何可能导致错误结果的决定。而直觉决策是指不做分析，基于匆忙的判断或直觉反应而做出致命的决定。它是与分析瘫痪相反的另一个极端。</p><ol start="4"><li>精炼<br>精炼环节就是对共创环节中得出的众多方案进行评估，从中筛选出团队认为最小可行性解决方案的过程。评估因素包括备选方案的实施成本、时间与人力、效果反馈周期，以及该方案对业务目标的影响程度。在VUCA环境中，时间是最大的隐形成本。精炼的目标并不是为了删除在共创阶段得出的解决方案，而是将它们按优先级排列，并让团队将解决方案进一步分解，顺序选出共同认可的最重要改进项，并确保它能够尽早被验证。</li></ol><h3 id="工作原则"><a href="#工作原则" class="headerlink" title="工作原则"></a>工作原则</h3><p>在探索环的工作中应该遵循“分解并快速试错”“一次只验证一点”“允许失败”原则。</p><ol><li><p>分解并快速试错<br>“一次到位式”解决方案通常需要较高的实施成本，而其带来的实际效果具有较高的不确定性。由于前期投入的成本较高（即沉没成本），一旦这个解决方案未能带来预期效果，团队不愿意放弃这一方案，决策者通常选择保留它，或者仍会持续优化，使其慢慢“死去”，而这会带来不必要的产品复杂度和维护成本。</p></li><li><p>一次只验证一点<br>一次只验证一个需求假设。在执行整个试验方案过程中，我们仍旧要保持开放心态，不断优化这些试验方案。时刻提醒自己，我们的目标是验证我们的假设，试验方案只是我们验证假设的手段，而不是我们的目标。</p></li><li><p>允许失败<br>尽管每个产品经理都希望所有方案都获得成功，但是我们却无法保证每个方案都会获得成功。但是，只要具有开放的心态，我们就可以从所有方案中都学到很多新的知识。</p></li></ol><h3 id="共创与精炼的常用方法"><a href="#共创与精炼的常用方法" class="headerlink" title="共创与精炼的常用方法"></a>共创与精炼的常用方法</h3><p>关于共创与精炼，书中花了大量篇幅介绍了6个常用方法，这里我只简单介绍2个。</p><ul><li><p>装饰窗方法<br>所谓装饰窗方法（Decorative Window），就是指为新功能预留一个“入口”，让用户能够看到，但实际上并没有真正实现其功能。这是一种了解用户喜好的方法，其目的是利用最小成本，来验证用户是否喜欢某个功能，以及其紧迫程度，为是否研发后续更全面的解决方案提供数据支持。</p></li><li><p>最小可行特性法<br>最小可行特性法（Minimum Viable Feature）是指在产品从1到n的过程中，寻找用户可直接感知到的需求假设作为产品的最小可行特性优先开发的方法，以尽可能少的成本快速增加或修改某个产品特性，让用户使用，收集真实反馈，专注于验证功能改进，同时也可提升用户使用体验。</p></li></ul><h2 id="快速验证环"><a href="#快速验证环" class="headerlink" title="快速验证环"></a>快速验证环</h2><p>当我们通过“探索环”对最小可行方案达成共识以后，要借助“验证环”的快速运转，才能将其交付到用户（客户）手中，从而得到真实且可靠的反馈，以验证之。快速验证环的运转速度由两部分决定:一是探索环中得出的最小可行性解决方案的大小和复杂性；二是验证环自身运转的速度。</p><h3 id="验证环的目标"><a href="#验证环的目标" class="headerlink" title="验证环的目标"></a>验证环的目标</h3><p>进入验证环的基本前提是“团队已达成共识，所选的方式是当前所处环境下，验证或解决业务领域问题的最佳方式“。验证环的目标就是借助各种方法与工具，让质量可靠的解决方案以最快的速度到达客户手中，从而收集并分析真实的反馈。</p><p>质量与速度是验证环的关键，它们却常常被认为是互斥的。然而， Puppet LabsDev发布的2017年DevOps现状调查报告结果显示，与低绩效IT组织相比，高绩效IT组织可以同时实现这两个目标，也就是说，发布质量好而且频率高。持续交付1.0在这方面发挥了巨大作用，如质量内建、小批量交付、自动化一切重复工作等。</p><h3 id="验证环的4个关键环节"><a href="#验证环的4个关键环节" class="headerlink" title="验证环的4个关键环节"></a>验证环的4个关键环节</h3><p>验证环的主要工作内容就是以最可靠的质量和最快的速度，将最小可行性解决方案从描述性语言转换成可运行的软件包，并将其部署到生产环境中运行，准确收集相关数据并<br>呈现，以便团队根据相关数据做出判断和决策。与探索环一样，它也包含4个环节，分别是构建、运行、监测和决策。</p><ol><li><p>构建<br>构建环节是将自然语言的描述转换成计算机可执行的软件，即“质量达标的软件包”。这一环节既要求相关人员能对业务问题及试验方案达成共识，又要求能够准确地将团队的意图转换成最终仅由0和1组成的数字程序。这一环节的参与角色最多，尤其当开发一个新产品或者产品有重大变更的时候，参与角色如业务人员、产品经理、开发工程师和测试工程师，以及运维工程师。每个角色的背景知识和技能优势各不相同，如何快速将人们头脑中的解决方案变成可以运行的高质量软件包，一直是软件工程领域的一个难题。这是验证环内不确定因素最多的一个环节。时间盒管理、工作任务分解和持续验证是应对这种不确定性的好方法。</p></li><li><p>运行<br>将达到质量要求的软件包部署到生产环境或交到用户手中，并使之为用户提供服务。</p></li><li><p>监测<br>监测环节收集数据，并统计展现结果、及时发现生产系统问题以及业务指标的异常波动，并做出适当的反应。它也是团队做出决策的最重要数据源之一。团队必须在验证环一开始就讨论并确定验证所需的数据需求，尽早讨论并定义数据需求规范制订日志记录标准，建立数据日志元数据，并与相对应的功能需求一并同时实现。</p></li><li><p>决策<br>决策是指收到真实的业务数据反馈结果后，根据探索环中已确定的相应衡量指标进行对比分析，从而验证是否符合最初的预期。下一步行动既可能是从精炼环节的最小可行方案列表中选择下一个试验方案，也可能是返回到持续交付“8”字环的起点，开始新问题的探索。</p></li></ol><h3 id="工作原则-1"><a href="#工作原则-1" class="headerlink" title="工作原则"></a>工作原则</h3><p>验证环的工作原则主要包括质量内建、消除等待、尽量并行、监测一切。</p><h1 id="二、组织机制"><a href="#二、组织机制" class="headerlink" title="二、组织机制"></a>二、组织机制</h1><p>组织机制是一个复杂课题，书中仅仅讨论持续交付所需的文化，以及建立文化的四步法。关于组织架构、人才结构、激励机制等内容被略去，不得不说是一个遗憾，当然我想更多的是篇幅所限，不得已而为之。</p><h2 id="组织文化塑造四步法"><a href="#组织文化塑造四步法" class="headerlink" title="组织文化塑造四步法"></a>组织文化塑造四步法</h2><p>书中列举了几个企业组织的四步法，但大同小异，这里我以谷歌工程师的质量文化为例，</p><ol><li>第一步:定义想要做的事情</li></ol><ul><li>提高代码质量，减少生产问题，减少手工测试工作量，快速发布软件。</li></ul><ol start="2"><li>第二步:定义期望的做事方法</li></ol><ul><li>开发团队编写自动化测试。</li><li>主动运行自动化测试用例。</li><li>做代码评审。</li></ul><ol start="3"><li>第三步:提供相应的培训</li></ol><ul><li>在公司范围内组织代码设计与自动化测试培训。</li><li>为每个团队指派自动化测试教练，帮助团队提高自动化测试技能。</li></ul><ol start="4"><li>第四步:做些必需的事情来强化那些行为</li></ol><ul><li>建立团队测试认证机制（test certified mechanism），共分3个大级别，12个子级，用于评估每个软件产品团队的测试成熟度。通过每个季度统计各级别上的团队数量分布，来评估自动化测试文化在公司内部的进展程度。</li><li>建立自动化测试组（ test group）和测试教练组（test mentor），帮助团队提升自动化测试能力。</li><li>建立代码评审资质证书。</li><li>代码合入版本仓库之前强制做代码评审。</li><li>代码评审之前，必须运行自动化测试用例，并提交报告给代码评审者。</li></ul><p>当然，这4步并不是非常容易的，谷歌的执行过程也花费了4年的时间，其中还有很多非常具体的细节，书中并没有展开讨论。</p><h2 id="行动原则"><a href="#行动原则" class="headerlink" title="行动原则"></a>行动原则</h2><p>行动原则有3个，分别是“价值导向，快速验证，持续学习”。</p><h3 id="价值导向"><a href="#价值导向" class="headerlink" title="价值导向"></a>价值导向</h3><p>所有人都会一致同意，“我们做事情时，应该价值导向”。然而，这却是在工作中经常被忽视的一点，也是最难判断的一点。因为我们每天有太多的事情要做。为了能够早一点儿完成所有任务，我们常常忘记思考完成这些任务的最终目的，以及它与目标之间的关系。为了能够做出正确的判断我们应该时常强迫自己停下来，花一些时间，认真思考一下我们手头上正在做的事情是否仍旧具有价值，是否仍旧最有价值。之所以难以判断，是由于组织中每个人的背景与经历各不相同，对外部市场环境的感知也各不相同，对于同一个工作场所带来的价值感也会有所不同。因此，当我们讨论“价值”时，应该限定于一定的业务上下文，避免离题太远。同时，在讨论时应该尽量提供完整的上下文，并聆听他人的方案与建议。<br>即便进行了充分的沟通与讨论，面对同一个问题的多种解决方案，我们可能也无法达成一致意见。此时，我们可以采用行动原则的第二原则，即“快速验证”。</p><h3 id="快速验证"><a href="#快速验证" class="headerlink" title="快速验证"></a>快速验证</h3><p>在高度不确定的环境中，并不是所有的方案都能很容易提前对其价值进行准确判断因此我们需要快速验证。通过快速实施，得到真实反馈，从而做出决策。在一个安全的工作环境中，只要我们能够主动拥抱“快速验证”原则，充分发挥员工的主观能动性，就可以找到很多快速试验方案。<br>对于与组织管理相关的改进，也可以使用快速验证方式。例如，针对具体问题，选择不同的试点团队进行快速实施，根据团队实际运行效果进行调优、验证。</p><h3 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h3><p>我们无法保证每个决策都是正确的。团队应当将每一次反馈作为一次学习的机会，结合从中学习到的新知识，总结成功经验或失败教训。除了通过业务试验产生的业务结果对业务领域进行深入了解和学习，还要保持对做事过程的学习与反思，不断优化工作流程，提升各环节的效率。<br>对于团队日常工作过程的学习与反思，有两种常见的方式，一是定期回顾，二是事件复盘机制。</p><p>关于持续学习，我认为是比较重要的，所以我重点介绍下持续学习。</p><h4 id="定期回顾"><a href="#定期回顾" class="headerlink" title="定期回顾"></a>定期回顾</h4><p>定期回顾是指每隔一定周期，团队主动安排一次会议，共同讨论在过去的这个周期内，团队在协作过程中的优点与不足，并讨论相应的对策，以便在后续的工作中能够保持优点，改进不足，持续取得进步。回顾会议结束后，应该有改进措施与计划，并能够跟踪执行结果。同时，不要制订过多的改进项，以免落入“反复提出，反复执行，没有实际进展”的境况。</p><h4 id="复盘机制"><a href="#复盘机制" class="headerlink" title="复盘机制"></a>复盘机制</h4><p>复盘机制通常是指针对发生的问题进行分析，其目的是避免相同问题重复出现。首先要针对问题发生的前后进行信息收集与整理确定问题的严重程度，理解问题发生的过程（对于疑难问题，可能还需要在事故后进行线下模拟测试，甚至线上测试，以复现问题和寻找原因）。然后进行根因分析，最后总结经验，制订改进措施与计划，并能够跟踪执行结果。对于根本原因分析，需要注意以下几点。</p><ol><li>放松心态，开放共享。</li><li>分清“因”和“果”。</li><li>五问法，鼓励多问“为什么”。</li><li>发挥群体智慧。</li><li>不要停于表面，而要寻找深层次原因。</li><li>对答案进行求证。</li></ol><p>对于每一次复盘，都应该详细记录和总结，作为知识在企业中全员共享。只有这样，才能收益最大化。</p><p>在以上两种学习方式中，都应该运用“系统思考”方法。简单来说，就是对事情全面思考，不能仅是就事论事，而是把想要获得的结果、实现该结果的过程、过程优化以及对未来的影响等一系列问题作为一个整体系统进行研究。在传统的思维模式中，人们假设因与果之间是线性作用的，即“因”产生“果”；但在系统思考中，因与果并不是绝对的，因与果之间有可能是环形互动的，即“因”产生“果”，此“果”又成为他“果”之“因”，甚至成为“因”之“因”。</p><h2 id="度量原则"><a href="#度量原则" class="headerlink" title="度量原则"></a>度量原则</h2><p>作为管理者，如果无法度量，很显然你也无法有效率的进行改进。所以，我们也必须有度量原则。度量指标可以分为4类属性，分别是引领性指标、滞后性指标、可观测性指标和可行动性指标。</p><ol><li>引领性指标与滞后性指标<br>引领性指标是指那些对达成预定目标有着重要作用的指标。通常，一个好的引领性指标有以下两个基本特点:第一，它具有预见性；第二，团队成员可以影响这些指标。</li></ol><p>滞后性指标是指那些为了达成最重要目标的跟踪性指标，如销售收入、利润率、市场份额、客户满意度等研究分析都属于滞后性指标。当你得到这些结果的时候，导致这些结果的事情早已结束，你得到的都是历史性结果数据。</p><p>例如，在其他因素相同的情况下，假如软件质量与性能越好，则软件的市场竞争力越强，客户就越愿意为之买单，软件销售量就会越高。对于软件销售这件事情，软件销售量就是一个滞后性指标，而软件质量与性能就是一个引领性指标。我们可以通过优化软件性能，提升软件质量来影响软件销售量，但无法确保一定达成软件销售量这一滞后性指标。<br>企业的终极后验性指标是客户价值，相对于这一滞后性指标来说，其他指标均可认为是引领性指标。</p><ol start="2"><li>可观测性指标与可行动性指标<br>可观测性指标是指可以被客观监测到，但无法通过直接行动来改变的指标。可行动性指标是指在能力可触达范围内，通过团队努力可以设法直接改变的指标。</li></ol><p>例如，千行代码缺陷率就是一种可观测性指标。我们无法以非常直接的方式来改变它，只能通过更全面的质量保障活动（写出高质量的代码、做更加完整的测试等活动）来影响这一指标。</p><p>代码规范符合度、代码圈复杂度、重复代码率则既是可观测性指标，也是可行动性指标，因为团队可以直接通过修改代码来直接影响和改变这些指标，但无法确保一定达成“千行代码缺陷率”这一后验性可观测性指标。</p><p>“DevOps状态报告2017”指出，衡量IT高绩效组织的4个度量项分别是发布频率、发布周期、MTBF&#x2F;MTTR、吞吐量。其中，发布频率是指软件部署并运行于生产环境的频率，例如， Facebook手机App每周发布一次。该报告中的发布周期是指从代码提交到发布之间的时间周期。MTBF，全称是 Mean Time Between Failure，即平均失效间隔。就是新的产品在规定的工作环境条件下从开始工作到出现第一个故障的时间的平均值。MTTR的全称是 Mean Time To Repair，即平均恢复时间，指从故障出现到恢复之间的时间周期。吞吐量是指在给定时间段内系统完成的交付物数量。</p><p><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/4-5-%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E9%A1%B9%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="软件度量项的相关性示意图"><br>假如将上述4个度量项作为滞后性指标的话，那么编译速度、测试时长、部署效率等指标则可能是达成这些目标的引领性指标。我们可以推断，从滞后性指标出发，一级一级地向前推导，可以发现很多可行动性的引领性指标。需要注意的是，指标之间的关联影响可能还存在时间延迟效应，即对某一个度量指标的改善，需要经过一段时间，才能在其关联度量指标上有所体现。并且，指标链条越长，可预测性就越低。</p><h1 id="三、软件架构"><a href="#三、软件架构" class="headerlink" title="三、软件架构"></a>三、软件架构</h1><h2 id="持续交付架构的要求"><a href="#持续交付架构的要求" class="headerlink" title="持续交付架构的要求"></a>持续交付架构的要求</h2><p>为了提升交互速度，获得持续交付能力，我们会需要对系统架构做一些调整。书中对系统架构做了一些要求，要求如下：</p><ol><li>为测试而设计（design for test）。如果我们每次写好代码以后，需要花费很大的精力，做很多的准备工作才能对它进行测试的话，那么从写好代码到完成质量验证就需要很<br>长周期，当然无法快速发布。</li><li>为部署而设计（design for deployment）如果我们开发完新功能，当部署发布时，需要花费很长时间准备，甚至需要停机才能部署，当然就无法快速发布。</li><li>为监控而设计（design for monitor）。如果我们的功能上线以后，无法对其进行监控，出了问题只能通过用户反馈才发现。那么，持续交付的收益就会大幅降低了。</li><li>为扩展而设计（design for scale）。这里的扩展性指两个方面，一是支持团队成员规模的扩展；二是支持系统自身的扩展。</li><li>为失效而设计（design for failure）俗语说“常在河边走，哪能不湿鞋。”快速地部署发布总会遇到问题。因此，在开发软件功能之前，就应该考虑的一个问题是:一旦部署或发布失败，如何优雅且快速地处理。</li></ol><h2 id="系统拆分原则"><a href="#系统拆分原则" class="headerlink" title="系统拆分原则"></a>系统拆分原则</h2><p>根据目前软件的发展趋势，以及持续交付的要求，对系统进行拆分有以下几个原则。</p><ol><li>作为系统的一部分，每个组件或服务有清晰的业务职责，可以被独立修改，甚至被另一种实现方案所替代。</li><li>“高内聚、低耦合”，使整个系统易于维护，每个组件或服务只知道尽可能少的信息，完成相对独立的单一功能。</li><li>整个系统易于构建与测试。将系统拆分后这些组件仍需要组合在一起，为用户提供服务。</li><li>使团队成员之间的沟通协作更加顺畅。</li></ol><h2 id="常见架构模式"><a href="#常见架构模式" class="headerlink" title="常见架构模式"></a>常见架构模式</h2><h3 id="微核架构"><a href="#微核架构" class="headerlink" title="微核架构"></a>微核架构</h3><p>微核架构（microcore architecture）又称为插件架构（plugin architecture），指的是软件的核心框架相对较小，而其主要业务功能和业务逻辑都通过插件实现，如图所示。核心框架部分通常只包含系统启动运行的基础功能，例如基础通信模块、基本渲染功能和界面整体框架等。插件则是互相独立的，插件之间的通信只通过核心框架进行，避免出现互相依赖的问题。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/5-1-%E5%BE%AE%E6%A0%B8%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="微核架构示意图"></p><p>这种架构方式的优点有以下几个：</p><ul><li>良好的功能延伸性（extensibility）:需要什么功能，开发一个插件即可。</li><li>易发布:插件可以独立地加载和卸载，使它比较容易发布。</li><li>易测试:功能之间是隔离的，可以对插件进行隔离测试。</li><li>可定制性高:适应不同的开发需要。</li><li>可以渐进式地开发:逐步增加功能。</li></ul><p>当然，它也有不足，具体有以下几点:</p><ul><li>扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式，但对客户端软件来说，这就不是一个严重问题。</li><li>开发难度相对较高，因为涉及插件与内核的通信以及内部的插件登记机制等，比较复杂。</li><li>高度依赖框架，既享受框架带来的方便性，当框架接口升级时又可能会影响所有插件，导致大量的改造工作。</li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构（microservice architecture）是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP协议的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。<br>这种软件架构的优点有以下几个。</p><ul><li>扩展性好——各个服务之间低耦合。可以对其中的个别服务单独扩容，如图所示的D服务。</li><li>易部署——每个服务都是可部署单元。</li><li>易开发每个组件都可以进行单独开发，单独部署，不间断地升级。</li><li>易于单独测试——如果修改只涉及单一服务，那么只测试该服务即可。</li></ul><p>但是，它也有不足，具体有以下几点。</p><ul><li>由于强调互相独立和低耦合，服务可能会被拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，网络通信消耗也会比较大。</li><li>一次外部请求会涉及内部多个服务之间的通信，使得问题的调试与诊断比较困难，需要更强大的工具支持。</li><li>为原子操作带来困难，例如需要事务类操作的场景。</li><li>跨服务的组合业务场景的测试比较困难，通常需要同时部署和启动多个微服务。公共类库的升级管理比较难。在使用有一些公共的工具性质的类库时，需要在构建每个微服务时都将其打包到部署包中。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/5-2-%E6%A0%B9%E6%8D%AE%E9%9C%80%E6%B1%82%E5%8D%95%E7%8B%AC%E5%A2%9E%E5%8A%A0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9D.jpg" alt="根据需求单独增加微服务节点D"></li></ul><p>在使用微服务架构模式时，除确保每个服务一定要能够独立部署之外，还要确保在部署升级时不影响其下游服务（例如通过支持API的多版本兼容方式），同时建立全面的微服务监测体系。</p><h3 id="巨石应用"><a href="#巨石应用" class="headerlink" title="巨石应用"></a>巨石应用</h3><p>巨石应用（monolithic application）也称巨石架构，是指由单一结构体组成的软件应用，其用户接口和数据访问代码都绑定在同一语言平台的同一应用程序。这种巨石架构应用通常表现为一个完整的包，如一个Jar包或者一个Node.js或 Rails的完整目录结构。只要有了这个包，就什么都有了。</p><p>组织良好的巨石架构同样也有其优势，包括以下几个。</p><ul><li>利于开发和调试:当前所有开发工具和IDE都很好地支持了巨石应用程序的开发。系统架构简单，调试方便。</li><li>部署操作本身比较简单:例如，只需要有运行时所需部署的一个WAR文件（或目录层次结构）即可。</li><li>很容易扩展:只要在负载均衡器后面运行这个应用的多个副本就可以扩展应用程序。</li></ul><p>它的劣势有以下几个。</p><ul><li>对整体程序不熟悉的人来说，容易产生混乱的代码，污染整个应用，给老代码的学习和理解带来困难。</li><li>难与新技术共同使用。</li><li>只能将整个应用作为一个整体进行扩展。</li><li>持续部署非常困难。为了更新一个组件，必须重新部署整个应用程序。</li></ul><h2 id="架构改造实施模式"><a href="#架构改造实施模式" class="headerlink" title="架构改造实施模式"></a>架构改造实施模式</h2><p>通常，这类改造有3种实施模式，分别是拆迁者模式、绞杀者模式和修缮者模式。其中，绞杀者模式和修缮者模式都有利于持续交付，降低架构改造和发布的风险。</p><h3 id="拆迁者模式"><a href="#拆迁者模式" class="headerlink" title="拆迁者模式"></a>拆迁者模式</h3><p>“拆迁者模式”就是指根据当前的业务需求，对软件架构重新设计，并组织单独的团队，重新开发一个全新的版本，一次性完全替代原有的遗留系统，如图所示。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/5-6-%E6%8B%86%E8%BF%81%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="拆迁者模式"></p><p>这种方式的好处在于，它与旧版本没有瓜葛，没有历史包袱，可以按预期进行架构设计。但是，这种模式的风险包括以下几个方面。</p><ol><li>业务需求遗漏。软件的历史版本中，有很多不为人熟知的功能还在使用。</li><li>市场环境变化。由于新版本架构无法一蹴而就，当市场需求发生变化时，就会错失市场良机。</li><li>人力资源消耗大。必须分出人力，一边维护旧版本的功能或紧急需求，一边要安排充分人力进行架构改造。</li><li>“闭门造车”。新版本上线后，无法满足业务需求。</li></ol><h3 id="绞杀者模式"><a href="#绞杀者模式" class="headerlink" title="绞杀者模式"></a>绞杀者模式</h3><p>“绞杀者模式”是指保持原来的遗留系统不变，当需要开发新的功能时，重新开发一个服务，实现新的功能。通过不断构建新的服务，逐步使遗留系统失效，并最终替代它，如图所示。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/5-7-%E7%BB%9E%E6%9D%80%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="绞杀者模式"></p><p>这种方式的好处在于:</p><ul><li>不会遗漏原有需求；</li><li>可以稳定地提供价值，频繁地交付版本，可以让你更好地监控其改造进展；</li><li>避免“闭门造车”现象。</li></ul><p>其劣势在于:</p><ul><li>架构改造的时间跨度会变大；</li><li>产生一定的迭代成本。</li></ul><h3 id="修缮者模式"><a href="#修缮者模式" class="headerlink" title="修缮者模式"></a>修缮者模式</h3><p>“修缮者模式”是指将遗留系统的部分功能与其余部分隔离，以新的架构进行单独改善。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/5-8-%E4%BF%AE%E7%BC%AE%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="修缮者模式"></p><p>其收益包括:</p><ul><li>系统外部无感知；</li><li>不会遗漏原有需求；</li><li>可以随时停下改造工作，响应高优先级的业务需求；</li><li>避免“闭门造车”现象。</li></ul><p>而其劣势在于:</p><ul><li>架构改造的时间跨度会变大；</li><li>会有更多额外的架构改造迭代成本。</li></ul><h3 id="数据库的拆分方法"><a href="#数据库的拆分方法" class="headerlink" title="数据库的拆分方法"></a>数据库的拆分方法</h3><p>一般来说，关系型数据库很可能是巨石应用中的最大耦合点.因此，对于有状态微服务的改造，我们需要非常小心地处理数据库数据做数据库拆分时，我们应该遵循以下步骤，如图所示。<br><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E8%A6%81%E7%82%B9%E6%91%98%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/5-10-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%94%B9%E9%80%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%86%E5%88%86%E5%A4%84%E7%90%86.jpg" alt="微服务改造中的数据库拆分处理"></p><ol><li>详细了解数据库结构，包括外键约束、共享的可变数据以及事务性边界等，如图a所示。</li><li>先拆分数据库，并按照12.3.2节的介绍进行数据迁移，如图b所示。</li><li>数据库双写无误后，找到程序架构中的缝隙，如图c所示。</li><li>将拆分出来的程序模块和数据库组合在一起，形成微服务，如图d所示。</li></ol><h1 id="四、基础设施"><a href="#四、基础设施" class="headerlink" title="四、基础设施"></a>四、基础设施</h1><p>前三个章节介绍了持续交付的概念，实施持续交付三大板块中的组织机制和软件架构，而最后一个板块则是基础设施。基础设施部分是产品研发过程中最基础的工作。</p><p>这部分涵盖持续交付部署流水线及其工具设计原则，以及建立该流水线和优化所需关注的五大领域，分别是，业务需求协作流程、分支与配置管理、构建与环境管理、自动化测试管理，以及部署发布与监控管理。这部分内容相当细节，我并不想在此展开。此外，此部分和目前流行的DevOps有大量共同的内容。</p><h2 id="部署流水线"><a href="#部署流水线" class="headerlink" title="部署流水线"></a>部署流水线</h2><p>为实现“谁构建，谁运营”，企业对于DevOps工具的建设，应该坚决从开发工程师的工作场景出发，为其构建强大的DevOps工具。不仅是生产环境的运维工具，而且是整个工作流程中的业务软件监控工程基础设施，它包括:</p><ul><li>基础的研发流程自助平台，如各类运行环境（构建、测试、生产）的自助平台；</li><li>数据自助平台（包括三层监测数据）；</li><li>用于业务快速试错的实验测量平台；</li><li>针对移动设备，建立用户触达平台。</li></ul><p>关于部署流水线，书中介绍了团队设计和使用部署流水线的原则，以及企业定制开发私有部署流水线工具链的设计要点和工具平台的能力要求。同时，还对四大基础支撑服务（编译构建服务、自动化测试服务、部署管理服务及基础环境服务）的逻辑组件进行了简要介绍。同时，还介绍了三大受信源（需求管理仓库、源代码仓库和制品库）之间的关联关系，以及对它们的管理要求。书中列举了几个不同的产品场景以及相应的部署流水线设计方案。</p><p>要想让部署流水线发挥最大的作用，研发团队需要尽可能遵守以下5条原则。</p><ol><li>任何软件包的取用皆须通过受控源，各角色之间禁止通过私有渠道（如电子邮件、即时通信工具等）获取。</li><li>尽可能将一切流程自动化，并持续优化执行时间。</li><li>每次提交都能够自动触发部署流水线。</li><li>尽可能地少用手动触发方式。</li><li>必须执行立即暂停原则（stop the line）</li></ol><h2 id="业务需求协作管理"><a href="#业务需求协作管理" class="headerlink" title="业务需求协作管理"></a>业务需求协作管理</h2><p>业务需求协作管理一章具体阐述了产品版本周期准备期、交付期的重点内容，以及需求拆分带来的收益与随之而来的固定成本。如果无法降低这些固定成本，那么很难收获更大的价值。为了能够真正获得拆分带来的收益，在做需求拆分时就要尽可能遵守 INVEST原则（INV&lt;EST）为了帮助读者更好地掌握拆分技术。书中总结了五大拆分技法，以及每个用户故事应该包含的7个组成部分。需求分析与管理的方法与工具有很多，用户故事地图、用户故事树和依赖关系图是较为常见的需求梳理工具。另外，书中还介绍了迭代过程中提高团队协作的工具与方法，包括共享时间表、回顾会议、持续集成和故事验证。</p><h2 id="分支与配置管理"><a href="#分支与配置管理" class="headerlink" title="分支与配置管理"></a>分支与配置管理</h2><p>关于版本控制系统，如果不是有能力自定义自己代码仓库功能特性的大厂，个人强烈建议使用git，可以节省很多不必要的时间。如果还在使用svn等传统工具的团队，应尽快迁移到git中，git有提供非常方便的工具，方便svn用户做迁移，提交记录等信息都能比较好的迁移到git中。关于分支与配置管理，书中分析了各种分支策略的优点和挑战。目前的发展趋势是:软件发布频率越来越高，发布周期越来越短。硅谷顶级互联网公司多采用“主干开发”或高频的 GitHubFlow分支模式。一个企业到底选择哪种分支策略，需要根据团队的具体情况来决定。如果相关的配套条件（如软件架构、人员能力和工具平台的成熟度）不足，那么，盲目提高发布频率、缩短发布周期会造成不必要的损失。</p><p>“持续交付2.0”提倡鼓励持续集成的分支策略，因此，选择分支模式的原则有以下几条。</p><ol><li>分支越少越好，最好只有一条主干。</li><li>分支生存周期越短越好，最好在3天以内。</li><li>在业务允许的前提下，发布周期越短越好。</li></ol><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>本书还花了一章的篇幅讲述了持续集成的起源，团队实施持续集成的原则，介绍了持续集成6步提交法，以及快速建立团队持续集成实践的5个步骤。</p><p>需要注意的是，并不是安装部署了一个持续集成服务器，每天用它进行自动化编译打包，就说明团队正在使用持续集成实践。要真正做到持续集成，获得最大的持续集成收益，需要做到以下6点：</p><ol><li>主干开发，频率提交代码。</li><li>每次提交都是完整有意义的工作。</li><li>提交构建阶段在10分钟之内完成。</li><li>提交构建失败后，立即修复；且其他人不得在修复之前提交代码。</li><li>应该在10分钟内修复失败，否则回滚引起失败的代码。</li><li>自动化构建成功后，团队对软件质量比较有信心。</li></ol><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>对交付频率的要求越高，希望前置周期越短，自动化测试就越为重要。书中阐述了软件快速交付对自动化测试的4项基本要求，即快速、便捷、可信和及时。为了能够做到这4点，需要以分层的自动化测试金字塔为指导合理设计自动化测试的实施策略，从而增加自动化测试的收益。对自动化测试的实践管理来说，有5条重要原则：</p><ol><li>自动化测试用例运行次数越多，平均成本越低，收益就越大。</li><li>自动化测试用例之间应该尽可能相互独立，互不影响。</li><li>在质量有保障的前提下，自动化测试用例的数量越少越好。</li><li>遗留代码的自动化测试编写应该从代码热区开始。</li><li>自动化测试用例从测试金字塔的中间层开始补充，投入产出比最高。</li></ol><h2 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h2><p>良好的软件配置管理是打造持续交付部署流水线、加速持续验证环的基础支撑。<br>本书讨论了软件配置管理的3个核心原则。</p><ol><li>对一切进行版本管理。</li><li>共享唯一受信源。</li><li>标准化与自动化。</li></ol><p>可以用下面5个问题来验证检查你是否对一切都做了版本管理。</p><ol><li>产品源代码和测试代码是否放入了版本控制系统。</li><li>软件应用的配置信息是否放入了版本控制系统。</li><li>各类环境的系统配置是否放入了版本控制系统。</li><li>自动化的构建和部署脚本是否放入了版本控制系统。</li><li>软件包是否进行了版本管理。</li></ol><p>另外，也可以用下面两个问题来检查软件配置管理是否做得足够好。</p><ol><li>只要从源代码仓库中检出产品源代码仓库，就可以一键式自动化地构建出完整软件包吗？</li><li>在没有他人的帮助下，任何团队成员都可以一键式自动化搭建出一套应用软件系统，用于体验产品新功能吗？</li></ol><h2 id="低风险发布"><a href="#低风险发布" class="headerlink" title="低风险发布"></a>低风险发布</h2><p>本节讨论了如何在快速部署发布的情况下通过多种技术手段降低风险，如开关技术、数据库迁移技术、蓝绿部署、金丝雀（灰度）发布、抽象分支以及暗部署等。并且强调，即便没有使用开关，假如团队能够一直使用“小步完整的代码提交”策略，也可以比较容易地做到将缺陷快速回滚。<br>在一些业务场景下，我们的确无法直接高频地对外发布软件。但是，如果我们能够使用本章介绍的方法持续向预生产环境进行发布与部署，就可以尽早获得软件的相关质量反馈，从而减少正式发布后的风险。如果我们能够将每次发布的平均成本降低到足够低，那么将会直接改变团队的产品研发流程。</p><h2 id="监测与决策"><a href="#监测与决策" class="headerlink" title="监测与决策"></a>监测与决策</h2><p>生产环境的监测范围包括3个层次，它们分别是“基础监测”“应用监测”和“业务监测“。尽管根据每一层次的特点，监测数据的采集方式有所不同，但是其处理流程基本一致。每个监测体系都包括数据收集、上报、整理、分析、展现与决策这几个环节。而对监测系统能力的衡量有3个维度，即数据的准确性、全面性与及时性。而抽样能力是提高监测灵活性、节约资源、提升用户体验的一种有效方法。<br>告警处理是研发人员和运维人员的常规工作但是，如果告警过多也会成为工作中的困扰，降低工作产出。因此，我们应该不断对告警点的设置与阈值计算方式进行优化，从而尽可能提升有效告警率。一旦告警成立，就需要启动问题处理流程。这个流程的最后两个环节“根因分析”和“根源解决”，是学习型组织的重要特征。<br>随着发布频率的提高，测试场景的复杂性提高，越来越多的团队开始找寻方法在生产环境上进行软件测试，这被称为测试活动右移。这种右移目前多发生于展示性软件，这类软件出错后的成本和影响相对较少。而对那些交易性软件或回收成本较高的软件来说，测试左移的趋势也比较明显。<br>右移的测试主要有两种类型。一是将测试用例在生产环境上自动运行。二是混沌工程，即通过注入“问题”，发现生产环境的潜在稳定性问题。 Netflix公司开发了一系列破坏性测试工具（Simian Army）可以促使工程师在软件设计与开发之时，就提前考虑各种失败的可能性，这被称为“为失败而设计（Design for Failure），从而提高生产环境的软件服务稳定性，为用户提供更好的服务体验。<br>当收集到真实的数据反馈以后，我们就可以用来印证我们在价值探索环中所提出的假设或目标，并通过主动关联分析，最终确定是继续进行更多的试验，还是重新再选择一条新的“路”。</p><h2 id="后续章节"><a href="#后续章节" class="headerlink" title="后续章节"></a>后续章节</h2><p>后续三个章节主要是实战案例的分析，分别代表不同类型的公司、不同大小的团队以及不同的软件产品特点。本书作者带领读者深入案例现场，了解当时状况，分析问题，并提出解决思路。由于是案例解析，此次不再摘录要点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概念篇&quot;&gt;&lt;a href=&quot;#一、概念篇&quot; class=&quot;headerlink&quot; title=&quot;一、概念篇&quot;&gt;&lt;/a&gt;一、概念篇&lt;/h1&gt;&lt;h2 id=&quot;为什么要持续交付？&quot;&gt;&lt;a href=&quot;#为什么要持续交付？&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《持续交付2.0 业务引领的DevOps精要》 一句话短评</title>
    <link href="https://fenixadar.github.io/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9F%AD%E8%AF%84/"/>
    <id>https://fenixadar.github.io/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9F%AD%E8%AF%84/</id>
    <published>2021-02-23T01:19:24.000Z</published>
    <updated>2023-01-16T01:31:48.808Z</updated>
    
    <content type="html"><![CDATA[<p>这本书带给鄙人诸多启发，DevOps，持续交付，都是近些年的热词，而本书作者分别从概念与原则，组织架构，软件架构，基础设施，案例剖析等几个方面很好的诠释了这两个热词，难得的是，这不仅仅只是概念，更有大量的具体操作方法和实践案例，很适合技术管理者和研发经理阅读。</p><p>评分：9 （满分为10分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">作者: 乔梁</span><br><span class="line">出版社: 人民邮电出版社</span><br><span class="line">出品方: 异步图书</span><br><span class="line">副标题: 业务引领的DevOps精要</span><br><span class="line">原作名: 持续交付2.0</span><br><span class="line">出版年: 2019年1月第1版</span><br><span class="line">页数: 327</span><br><span class="line">定价: 89.00元</span><br><span class="line">装帧: 平装</span><br><span class="line">ISBN: 978-7-115-50001-4</span><br></pre></td></tr></table></figure><p><img src="/2021/02/23/%E3%80%8A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982-0-%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81%E3%80%8B-%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9F%AD%E8%AF%84/%E5%B0%81%E9%9D%A2.jpg" alt="封面"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书带给鄙人诸多启发，DevOps，持续交付，都是近些年的热词，而本书作者分别从概念与原则，组织架构，软件架构，基础设施，案例剖析等几个方面很好的诠释了这两个热词，难得的是，这不仅仅只是概念，更有大量的具体操作方法和实践案例，很适合技术管理者和研发经理阅读。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>写在开始本博客开始之前</title>
    <link href="https://fenixadar.github.io/2021/01/21/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D/"/>
    <id>https://fenixadar.github.io/2021/01/21/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D/</id>
    <published>2021-01-21T03:38:58.000Z</published>
    <updated>2023-01-16T01:31:48.808Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本博客主要用于自己做总结沉淀。</li><li>本博客佛系经营，不刻意推广，不定期更新，一切随缘。</li><li>内容上，一是不追求全面完整，如只是教程，网上到处都是，无必要重写一遍。可能更多的是我提一些要点，放参考链接的形式。二是，想发一些自己曾经研究过，自己喜欢的知识和技能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本博客主要用于自己做总结沉淀。&lt;/li&gt;
&lt;li&gt;本博客佛系经营，不刻意推广，不定期更新，一切随缘。&lt;/li&gt;
&lt;li&gt;内容上，一是不追求全面完整，如只是教程，网上到处都是，无必要重写一遍。可能更多的是我提一些要点，放参考链接的形式。二是，想发一些自己曾经研究过</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021新年寄语</title>
    <link href="https://fenixadar.github.io/2021/01/19/2021%E6%96%B0%E5%B9%B4%E5%AF%84%E8%AF%AD/"/>
    <id>https://fenixadar.github.io/2021/01/19/2021%E6%96%B0%E5%B9%B4%E5%AF%84%E8%AF%AD/</id>
    <published>2021-01-19T09:43:28.000Z</published>
    <updated>2023-01-16T01:31:48.808Z</updated>
    
    <content type="html"><![CDATA[<p>过往的2020年真是令人终身难忘的大年，一场突如其来的疫情打乱了所有人的节奏，以前总觉得亲历历史是非常幸运的，现在回想自己还是太天真幼稚了，亲历历史更多带来的是苦难。辗转来到了2021年，终于，在2020年开个属于自己的博客的小愿望还是没能实现，虽然这已经是在2019年就计划了的，但总有诸多现实且世俗的因素使自己有借口原谅自己的拖沓。</p><p>如果只用单个词作为2020年的年度词，那就是虚拟化，这是2020年我的最大的收获，它直接为我打开了一扇大门，一扇能让我极度方便的实践各个技术路线的大门。在此之前，遇到的最大痛点就是环境问题，每次学习实验某个语言，某个平台，某个框架，我可能得在本地计算机安装相应的程序，或是做某些配置。于是，计算机里面充斥着各种语言平台，各种IDE，各种工具，各种环境变量，最后把机器搞成八国联军，甚至卡顿，环境变量冲突，给自己挖了不少坑。一直到我知道了vSphere之后，这一切就再也不是问题，我可以迅速的通过vCenter创建一个清洁的系统，安装部署自己所需要的环境。</p><p>搭建虚拟机集群服务器过程中，踩了不少坑，特别是探索最佳实践方式花了不少时间。该选哪种软路由系统比较合适，网络拓扑结构该如何设计，怎么配置acl、vlan等才既能保证一定的安全性，又保障易用性。期间又陆续出现各种原因导致的网络连接不稳定，简而言之，一个典型的三边工程，就这么磕磕绊绊边搞边验证了3个月，算是基本稳定下来了。</p><p>2020年也意识到自己需要加强对运维侧的理解。意识到这个点的原因是，在项目研发过程中，并没有考虑太多运维侧的东西，以至于在上线后，当出现一些莫名其妙的问题时，运维人员和开发人员都不能及时发现、分析、解决问题，运维忙于救火，开发维护成本过大。也是因为如此，今年花了不少时间整体性的了解devops，希望它能成为我保证项目质量的一颗银弹。</p><p>2021年，我想进一步了解并初步实践DevOps，如果可能的话，我希望再加上安全，也就是能实践基础版本的DevSecOps。我计划设计一个DevOps平台，并在实际的工作中加以实践。针对项目中会遇到的爆发性强，难预测，响应要求高，可用性要求高等特点，该DevOps平台应该包含项目管理，持续集成，自动部署，弹性伸缩，高可用，监控告警，微服务治理等功能，从需求、研发、构建、部署到最后的运维保障，全生命周期提供支撑和管理能力。该平台尽可能用开源项目搭建，截止目前，项目管理已采用禅道开源版，已稳定运行一段时间，容器使用docker，代码管理使用gitlab。CI&#x2F;CD采用jenkins，但还在建设中。至于容器编排，制品管理，监控告警等其他模块，还未开始实质意义上的技术选型，但我想随着项目推进，研发人员到岗，我就能从各种杂事中脱身，肯定会逐渐加快脚步。如果进展顺利的话，我还想适当加入安全侧的模块，将安全左移，从代码审计，业务安全着手，再深入到蜜罐系统，WAF等等。</p><p>2021年，我也希望，我能真正的开写这个博客，可能未必很频繁的更新，但自己应该在忙碌中抽出一些时间做总结整理，真正沉淀些自己的东西。</p><p>预祝一切如愿。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;过往的2020年真是令人终身难忘的大年，一场突如其来的疫情打乱了所有人的节奏，以前总觉得亲历历史是非常幸运的，现在回想自己还是太天真幼稚了，亲历历史更多带来的是苦难。辗转来到了2021年，终于，在2020年开个属于自己的博客的小愿望还是没能实现，虽然这已经是在2019年就计</summary>
      
    
    
    
    
  </entry>
  
</feed>
